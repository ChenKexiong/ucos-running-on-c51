C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 10:39:23 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE OS_TMR
OBJECT MODULE PLACED IN .\Output\os_tmr.obj
COMPILER INVOKED BY: D:\Keil\C51\BIN\C51.EXE Source\os_tmr.c BROWSE INCDIR(.\Source) DEBUG OBJECTEXTEND PRINT(.\List\os_
                    -tmr.lst) TABS(2) OBJECT(.\Output\os_tmr.obj)

line level    source

   1          /*
   2          **********************************************************************************************************
             -**************
   3          *                                                uC/OS-II
   4          *                                          The Real-Time Kernel
   5          *                                            TIMER MANAGEMENT
   6          *
   7          *                              (c) Copyright 1992-2009, Micrium, Weston, FL
   8          *                                           All Rights Reserved
   9          *
  10          *
  11          * File    : OS_TMR.C
  12          * By      : Jean J. Labrosse
  13          * Version : V2.91
  14          *
  15          * LICENSING TERMS:
  16          * ---------------
  17          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
  18          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license
  19          * its use in your product. We provide ALL the source code for your convenience and to help you experience
  20          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
  21          * licensing fee.
  22          **********************************************************************************************************
             -**************
  23          */
  24          
  25          #include <ucos_ii.h>
*** WARNING C318 IN LINE 44 OF .\Source\ucos_ii.h: can't open file 'app_cfg.h'
*** WARNING C318 IN LINE 45 OF .\Source\ucos_ii.h: can't open file 'os_cfg.h'
*** WARNING C322 IN LINE 72 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 81 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 170 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 345 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 351 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 351 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 351 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 351 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 351 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 351 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 372 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 372 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 419 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 433 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 433 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 463 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 479 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 506 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 520 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 537 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 548 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 548 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 548 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 548 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 548 OF .\Source\ucos_ii.h: unknown identifier
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 10:39:23 PAGE 2   

*** WARNING C322 IN LINE 552 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 552 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 552 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 552 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 552 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 552 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 556 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 556 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 556 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 560 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 560 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 577 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 581 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 589 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 593 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 605 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 646 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 646 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 646 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 646 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 646 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 646 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 651 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 651 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 656 OF .\Source\ucos_ii.h: unknown identifier
*** ERROR C202 IN LINE 672 OF .\Source\ucos_ii.h: 'OS_LOWEST_PRIO': undefined identifier
*** ERROR C136 IN LINE 672 OF .\Source\ucos_ii.h: invalid dimension size: [0]
*** ERROR C202 IN LINE 684 OF .\Source\ucos_ii.h: 'OS_TASK_IDLE_STK_SIZE': undefined identifier
*** ERROR C136 IN LINE 684 OF .\Source\ucos_ii.h: invalid dimension size: [0]
*** ERROR C202 IN LINE 691 OF .\Source\ucos_ii.h: 'OS_LOWEST_PRIO': undefined identifier
*** ERROR C136 IN LINE 691 OF .\Source\ucos_ii.h: invalid dimension size: [0]
*** ERROR C202 IN LINE 692 OF .\Source\ucos_ii.h: 'OS_MAX_TASKS': undefined identifier
*** ERROR C136 IN LINE 692 OF .\Source\ucos_ii.h: invalid dimension size: [0]
*** WARNING C322 IN LINE 694 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 698 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 698 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 703 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 703 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 708 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 712 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 743 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 743 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 743 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 743 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 743 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 771 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 771 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 823 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 870 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 870 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 904 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 940 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 940 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 999 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 1044 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 1049 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 1056 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 1068 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 1073 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 1083 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 1088 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 1088 OF .\Source\ucos_ii.h: unknown identifier
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 10:39:23 PAGE 3   

*** WARNING C322 IN LINE 1093 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 1100 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 1120 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 1127 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 1131 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 1144 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 1193 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 1212 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 1216 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 1216 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 1216 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 1216 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 1216 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 1237 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 1237 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 1249 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 1249 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 1253 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 1259 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 1259 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 1259 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 1259 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 1267 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 1271 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 1271 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 1277 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 1277 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 1289 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 1301 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 1321 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 1327 OF .\Source\ucos_ii.h: unknown identifier
*** WARNING C322 IN LINE 1339 OF .\Source\ucos_ii.h: unknown identifier
*** ERROR C320 IN LINE 1393 OF .\Source\ucos_ii.h: "OS_CFG.H, Missing OS_FLAG_EN: Enable (1) or Disable (0) code generat
             -ion for Event Flags"
*** ERROR C320 IN LINE 1435 OF .\Source\ucos_ii.h: "OS_CFG.H, Missing OS_MBOX_EN: Enable (1) or Disable (0) code generat
             -ion for MAILBOXES"
*** ERROR C320 IN LINE 1469 OF .\Source\ucos_ii.h: "OS_CFG.H, Missing OS_MEM_EN: Enable (1) or Disable (0) code generati
             -on for MEMORY MANAGER"
*** ERROR C320 IN LINE 1495 OF .\Source\ucos_ii.h: "OS_CFG.H, Missing OS_MUTEX_EN: Enable (1) or Disable (0) code genera
             -tion for MUTEX"
*** ERROR C320 IN LINE 1517 OF .\Source\ucos_ii.h: "OS_CFG.H, Missing OS_Q_EN: Enable (1) or Disable (0) code generation
             - for QUEUES"
*** ERROR C320 IN LINE 1567 OF .\Source\ucos_ii.h: "OS_CFG.H, Missing OS_SEM_EN: Enable (1) or Disable (0) code generati
             -on for SEMAPHORES"
*** ERROR C320 IN LINE 1597 OF .\Source\ucos_ii.h: "OS_CFG.H, Missing OS_MAX_TASKS: Max. number of tasks in your applica
             -tion"
*** WARNING C322 IN LINE 1609 OF .\Source\ucos_ii.h: unknown identifier
*** ERROR C320 IN LINE 1614 OF .\Source\ucos_ii.h: "OS_CFG.H, Missing OS_TASK_IDLE_STK_SIZE: Idle task stack size"
*** ERROR C320 IN LINE 1618 OF .\Source\ucos_ii.h: "OS_CFG.H, Missing OS_TASK_STAT_EN: Enable (1) or Disable(0) the stat
             -istics task"
*** ERROR C320 IN LINE 1622 OF .\Source\ucos_ii.h: "OS_CFG.H, Missing OS_TASK_STAT_STK_SIZE: Statistics task stack size"
*** ERROR C320 IN LINE 1626 OF .\Source\ucos_ii.h: "OS_CFG.H, Missing OS_TASK_STAT_STK_CHK_EN: Check task stacks from st
             -atistics task"
*** ERROR C320 IN LINE 1630 OF .\Source\ucos_ii.h: "OS_CFG.H, Missing OS_TASK_CHANGE_PRIO_EN: Include code for OSTaskCha
             -ngePrio()"
*** ERROR C320 IN LINE 1634 OF .\Source\ucos_ii.h: "OS_CFG.H, Missing OS_TASK_CREATE_EN: Include code for OSTaskCreate()
             -"
*** ERROR C320 IN LINE 1638 OF .\Source\ucos_ii.h: "OS_CFG.H, Missing OS_TASK_CREATE_EXT_EN: Include code for OSTaskCrea
             -teExt()"
*** ERROR C320 IN LINE 1642 OF .\Source\ucos_ii.h: "OS_CFG.H, Missing OS_TASK_DEL_EN: Include code for OSTaskDel()"
*** ERROR C320 IN LINE 1646 OF .\Source\ucos_ii.h: "OS_CFG.H, Missing OS_TASK_NAME_EN: Enable task names"
*** ERROR C320 IN LINE 1650 OF .\Source\ucos_ii.h: "OS_CFG.H, Missing OS_TASK_SUSPEND_EN: Include code for OSTaskSuspend
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 10:39:23 PAGE 4   

             -() and OSTaskResume()"
*** ERROR C320 IN LINE 1654 OF .\Source\ucos_ii.h: "OS_CFG.H, Missing OS_TASK_QUERY_EN: Include code for OSTaskQuery()"
*** ERROR C320 IN LINE 1658 OF .\Source\ucos_ii.h: "OS_CFG.H, Missing OS_TASK_REG_TBL_SIZE: Include code for task specif
             -ic registers"
*** ERROR C320 IN LINE 1672 OF .\Source\ucos_ii.h: "OS_CFG.H, Missing OS_TICKS_PER_SEC: Sets the number of ticks in one 
             -second"
*** ERROR C320 IN LINE 1676 OF .\Source\ucos_ii.h: "OS_CFG.H, Missing OS_TIME_DLY_HMSM_EN: Include code for OSTimeDlyHMS
             -M()"
*** ERROR C320 IN LINE 1680 OF .\Source\ucos_ii.h: "OS_CFG.H, Missing OS_TIME_DLY_RESUME_EN: Include code for OSTimeDlyR
             -esume()"
*** ERROR C320 IN LINE 1684 OF .\Source\ucos_ii.h: "OS_CFG.H, Missing OS_TIME_GET_SET_EN: Include code for OSTimeGet() a
             -nd OSTimeSet()"
*** ERROR C320 IN LINE 1694 OF .\Source\ucos_ii.h: "OS_CFG.H, Missing OS_TMR_EN: When (1) enables code generation for Ti
             -mer Management"
*** ERROR C320 IN LINE 1746 OF .\Source\ucos_ii.h: "OS_CFG.H, Missing OS_ARG_CHK_EN: Enable (1) or Disable (0) argument 
             -checking"
*** ERROR C320 IN LINE 1751 OF .\Source\ucos_ii.h: "OS_CFG.H, Missing OS_CPU_HOOKS_EN: uC/OS-II hooks are found in the p
             -rocessor port files when 1"
*** ERROR C320 IN LINE 1756 OF .\Source\ucos_ii.h: "OS_CFG.H, Missing OS_APP_HOOKS_EN: Application-defined hooks are cal
             -led from the uC/OS-II hooks"
*** ERROR C320 IN LINE 1761 OF .\Source\ucos_ii.h: "OS_CFG.H, Missing OS_DEBUG_EN: Allows you to include variables for d
             -ebugging or not"
*** ERROR C320 IN LINE 1766 OF .\Source\ucos_ii.h: "OS_CFG.H, Missing OS_LOWEST_PRIO: Defines the lowest priority that c
             -an be assigned"
*** ERROR C320 IN LINE 1771 OF .\Source\ucos_ii.h: "OS_CFG.H, Missing OS_MAX_EVENTS: Max. number of event control blocks
             - in your application"
*** ERROR C320 IN LINE 1780 OF .\Source\ucos_ii.h: "OS_CFG.H, Missing OS_SCHED_LOCK_EN: Include code for OSSchedLock() a
             -nd OSSchedUnlock()"
*** ERROR C320 IN LINE 1785 OF .\Source\ucos_ii.h: "OS_CFG.H, Missing OS_EVENT_MULTI_EN: Include code for OSEventPendMul
             -ti()"
*** ERROR C320 IN LINE 1790 OF .\Source\ucos_ii.h: "OS_CFG.H, Missing OS_TASK_PROFILE_EN: Include data structure for run
             --time task profiling"
*** ERROR C320 IN LINE 1795 OF .\Source\ucos_ii.h: "OS_CFG.H, Missing OS_TASK_SW_HOOK_EN: Allows you to include the code
             - for OSTaskSwHook() or not"
*** ERROR C320 IN LINE 1800 OF .\Source\ucos_ii.h: "OS_CFG.H, Missing OS_TICK_STEP_EN: Allows to 'step' one tick at a ti
             -me with uC/OS-View"
*** ERROR C320 IN LINE 1805 OF .\Source\ucos_ii.h: "OS_CFG.H, Missing OS_TIME_TICK_HOOK_EN: Allows you to include the co
             -de for OSTimeTickHook() or not"
  26          
  27          /*
  28          **********************************************************************************************************
             -**************
  29          *                                                        NOTES
  30          *
  31          * 1) Your application MUST define the following #define constants:
  32          *
  33          *    OS_TASK_TMR_PRIO          The priority of the Timer management task
  34          *    OS_TASK_TMR_STK_SIZE      The size     of the Timer management task's stack
  35          *
  36          * 2) You must call OSTmrSignal() to notify the Timer management task that it's time to update the timers.
  37          **********************************************************************************************************
             -**************
  38          */
  39          
  40          /*
  41          **********************************************************************************************************
             -**************
  42          *                                                     CONSTANTS
  43          **********************************************************************************************************
             -**************
  44          */
  45          
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 10:39:23 PAGE 5   

  46          #define  OS_TMR_LINK_DLY       0u
  47          #define  OS_TMR_LINK_PERIODIC  1u
  48          
  49          /*
  50          **********************************************************************************************************
             -**************
  51          *                                                  LOCAL PROTOTYPES
  52          **********************************************************************************************************
             -**************
  53          */
  54          
  55          #if OS_TMR_EN > 0u
*** WARNING C322 IN LINE 55 OF Source\os_tmr.c: unknown identifier
              static  OS_TMR  *OSTmr_Alloc         (void);
              static  void     OSTmr_Free          (OS_TMR *ptmr);
              static  void     OSTmr_InitTask      (void);
              static  void     OSTmr_Link          (OS_TMR *ptmr, INT8U type);
              static  void     OSTmr_Unlink        (OS_TMR *ptmr);
              static  void     OSTmr_Task          (void   *p_arg);
              #endif
  63          
  64          /*$PAGE*/
  65          /*
  66          **********************************************************************************************************
             -**************
  67          *                                                   CREATE A TIMER
  68          *
  69          * Description: This function is called by your application code to create a timer.
  70          *
  71          * Arguments  : dly           Initial delay.
  72          *                            If the timer is configured for ONE-SHOT mode, this is the timeout used
  73          *                            If the timer is configured for PERIODIC mode, this is the first timeout to wa
             -it for
  74          *                               before the timer starts entering periodic mode
  75          *
  76          *              period        The 'period' being repeated for the timer.
  77          *                               If you specified 'OS_TMR_OPT_PERIODIC' as an option, when the timer expire
             -s, it will
  78          *                               automatically restart with the same period.
  79          *
  80          *              opt           Specifies either:
  81          *                               OS_TMR_OPT_ONE_SHOT       The timer counts down only once
  82          *                               OS_TMR_OPT_PERIODIC       The timer counts down and then reloads itself
  83          *
  84          *              callback      Is a pointer to a callback function that will be called when the timer expire
             -s.  The
  85          *                               callback function must be declared as follows:
  86          *
  87          *                               void MyCallback (OS_TMR *ptmr, void *p_arg);
  88          *
  89          *              callback_arg  Is an argument (a pointer) that is passed to the callback function when it is
             - called.
  90          *
  91          *              pname         Is a pointer to an ASCII string that is used to name the timer.  Names are us
             -eful for
  92          *                               debugging.
  93          *
  94          *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
  95          *                               OS_ERR_NONE
  96          *                               OS_ERR_TMR_INVALID_DLY     you specified an invalid delay
  97          *                               OS_ERR_TMR_INVALID_PERIOD  you specified an invalid period
  98          *                               OS_ERR_TMR_INVALID_OPT     you specified an invalid option
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 10:39:23 PAGE 6   

  99          *                               OS_ERR_TMR_ISR             if the call was made from an ISR
 100          *                               OS_ERR_TMR_NON_AVAIL       if there are no free timers from the timer pool
 101          *
 102          * Returns    : A pointer to an OS_TMR data structure.
 103          *              This is the 'handle' that your application will use to reference the timer created.
 104          **********************************************************************************************************
             -**************
 105          */
 106          
 107          #if OS_TMR_EN > 0u
*** WARNING C322 IN LINE 107 OF Source\os_tmr.c: unknown identifier
              OS_TMR  *OSTmrCreate (INT32U           dly,
                                    INT32U           period,
                                    INT8U            opt,
                                    OS_TMR_CALLBACK  callback,
                                    void            *callback_arg,
                                    INT8U           *pname,
                                    INT8U           *perr)
              {
                  OS_TMR   *ptmr;
              
              
              #ifdef OS_SAFETY_CRITICAL
                  if (perr == (INT8U *)0) {
                      OS_SAFETY_CRITICAL_EXCEPTION();
                  }
              #endif
              
              #ifdef OS_SAFETY_CRITICAL_IEC61508
                  if (OSSafetyCriticalStartFlag == OS_TRUE) {
                      OS_SAFETY_CRITICAL_EXCEPTION();
                  }
              #endif
              
              #if OS_ARG_CHK_EN > 0u
                  switch (opt) {                                          /* Validate arguments                         
             -            */
                      case OS_TMR_OPT_PERIODIC:
                           if (period == 0u) {
                               *perr = OS_ERR_TMR_INVALID_PERIOD;
                               return ((OS_TMR *)0);
                           }
                           break;
              
                      case OS_TMR_OPT_ONE_SHOT:
                           if (dly == 0u) {
                               *perr = OS_ERR_TMR_INVALID_DLY;
                               return ((OS_TMR *)0);
                           }
                           break;
              
                      default:
                           *perr = OS_ERR_TMR_INVALID_OPT;
                           return ((OS_TMR *)0);
                  }
              #endif
                  if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR          
             -            */
                      *perr  = OS_ERR_TMR_ISR;
                      return ((OS_TMR *)0);
                  }
                  OSSchedLock();
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 10:39:23 PAGE 7   

                  ptmr = OSTmr_Alloc();                                   /* Obtain a timer from the free pool          
             -            */
                  if (ptmr == (OS_TMR *)0) {
                      OSSchedUnlock();
                      *perr = OS_ERR_TMR_NON_AVAIL;
                      return ((OS_TMR *)0);
                  }
                  ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet     
             -            */
                  ptmr->OSTmrDly         = dly;
                  ptmr->OSTmrPeriod      = period;
                  ptmr->OSTmrOpt         = opt;
                  ptmr->OSTmrCallback    = callback;
                  ptmr->OSTmrCallbackArg = callback_arg;
              #if OS_TMR_CFG_NAME_EN > 0u
                  ptmr->OSTmrName        = pname;
              #endif
                  OSSchedUnlock();
                  *perr = OS_ERR_NONE;
                  return (ptmr);
              }
              #endif
 177          
 178          /*$PAGE*/
 179          /*
 180          **********************************************************************************************************
             -**************
 181          *                                                   DELETE A TIMER
 182          *
 183          * Description: This function is called by your application code to delete a timer.
 184          *
 185          * Arguments  : ptmr          Is a pointer to the timer to stop and delete.
 186          *
 187          *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
 188          *                               OS_ERR_NONE
 189          *                               OS_ERR_TMR_INVALID        'ptmr'  is a NULL pointer
 190          *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
 191          *                               OS_ERR_TMR_ISR            if the function was called from an ISR
 192          *                               OS_ERR_TMR_INACTIVE       if the timer was not created
 193          *                               OS_ERR_TMR_INVALID_STATE  the timer is in an invalid state
 194          *
 195          * Returns    : OS_TRUE       If the call was successful
 196          *              OS_FALSE      If not
 197          **********************************************************************************************************
             -**************
 198          */
 199          
 200          #if OS_TMR_EN > 0u
*** WARNING C322 IN LINE 200 OF Source\os_tmr.c: unknown identifier
              BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
                                 INT8U   *perr)
              {
              #ifdef OS_SAFETY_CRITICAL
                  if (perr == (INT8U *)0) {
                      OS_SAFETY_CRITICAL_EXCEPTION();
                  }
              #endif
              
              #if OS_ARG_CHK_EN > 0u
                  if (ptmr == (OS_TMR *)0) {
                      *perr = OS_ERR_TMR_INVALID;
                      return (OS_FALSE);
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 10:39:23 PAGE 8   

                  }
              #endif
                  if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                   
             -            */
                      *perr = OS_ERR_TMR_INVALID_TYPE;
                      return (OS_FALSE);
                  }
                  if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR          
             -            */
                      *perr  = OS_ERR_TMR_ISR;
                      return (OS_FALSE);
                  }
                  OSSchedLock();
                  switch (ptmr->OSTmrState) {
                      case OS_TMR_STATE_RUNNING:
                           OSTmr_Unlink(ptmr);                            /* Remove from current wheel spoke            
             -            */
                           OSTmr_Free(ptmr);                              /* Return timer to free list of timers        
             -            */
                           OSSchedUnlock();
                           *perr = OS_ERR_NONE;
                           return (OS_TRUE);
              
                      case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...               
             -            */
                      case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time  
             -            */
                           OSTmr_Free(ptmr);                              /* Return timer to free list of timers        
             -            */
                           OSSchedUnlock();
                           *perr = OS_ERR_NONE;
                           return (OS_TRUE);
              
                      case OS_TMR_STATE_UNUSED:                           /* Already deleted                            
             -            */
                           OSSchedUnlock();
                           *perr = OS_ERR_TMR_INACTIVE;
                           return (OS_FALSE);
              
                      default:
                           OSSchedUnlock();
                           *perr = OS_ERR_TMR_INVALID_STATE;
                           return (OS_FALSE);
                  }
              }
              #endif
 252          
 253          /*$PAGE*/
 254          /*
 255          **********************************************************************************************************
             -**************
 256          *                                             GET THE NAME OF A TIMER
 257          *
 258          * Description: This function is called to obtain the name of a timer.
 259          *
 260          * Arguments  : ptmr          Is a pointer to the timer to obtain the name for
 261          *
 262          *              pdest         Is a pointer to pointer to where the name of the timer will be placed.
 263          *
 264          *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
 265          *                               OS_ERR_NONE               The call was successful
 266          *                               OS_ERR_TMR_INVALID_DEST   'pdest' is a NULL pointer
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 10:39:23 PAGE 9   

 267          *                               OS_ERR_TMR_INVALID        'ptmr'  is a NULL pointer
 268          *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
 269          *                               OS_ERR_NAME_GET_ISR       if the call was made from an ISR
 270          *                               OS_ERR_TMR_INACTIVE       'ptmr'  points to a timer that is not active
 271          *                               OS_ERR_TMR_INVALID_STATE  the timer is in an invalid state
 272          *
 273          * Returns    : The length of the string or 0 if the timer does not exist.
 274          **********************************************************************************************************
             -**************
 275          */
 276          
 277          #if OS_TMR_EN > 0u && OS_TMR_CFG_NAME_EN > 0u
*** WARNING C322 IN LINE 277 OF Source\os_tmr.c: unknown identifier
*** WARNING C322 IN LINE 277 OF Source\os_tmr.c: unknown identifier
              INT8U  OSTmrNameGet (OS_TMR   *ptmr,
                                   INT8U   **pdest,
                                   INT8U    *perr)
              {
                  INT8U  len;
              
              
              #ifdef OS_SAFETY_CRITICAL
                  if (perr == (INT8U *)0) {
                      OS_SAFETY_CRITICAL_EXCEPTION();
                  }
              #endif
              
              #if OS_ARG_CHK_EN > 0u
                  if (pdest == (INT8U **)0) {
                      *perr = OS_ERR_TMR_INVALID_DEST;
                      return (0u);
                  }
                  if (ptmr == (OS_TMR *)0) {
                      *perr = OS_ERR_TMR_INVALID;
                      return (0u);
                  }
              #endif
                  if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                        
             -            */
                      *perr = OS_ERR_TMR_INVALID_TYPE;
                      return (0u);
                  }
                  if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR               
             -            */
                      *perr = OS_ERR_NAME_GET_ISR;
                      return (0u);
                  }
                  OSSchedLock();
                  switch (ptmr->OSTmrState) {
                      case OS_TMR_STATE_RUNNING:
                      case OS_TMR_STATE_STOPPED:
                      case OS_TMR_STATE_COMPLETED:
                           *pdest = ptmr->OSTmrName;
                           len    = OS_StrLen(*pdest);
                           OSSchedUnlock();
                           *perr = OS_ERR_NONE;
                           return (len);
              
                      case OS_TMR_STATE_UNUSED:                      /* Timer is not allocated                          
             -            */
                           OSSchedUnlock();
                           *perr = OS_ERR_TMR_INACTIVE;
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 10:39:23 PAGE 10  

                           return (0u);
              
                      default:
                           OSSchedUnlock();
                           *perr = OS_ERR_TMR_INVALID_STATE;
                           return (0u);
                  }
              }
              #endif
 332          
 333          /*$PAGE*/
 334          /*
 335          **********************************************************************************************************
             -**************
 336          *                                    GET HOW MUCH TIME IS LEFT BEFORE A TIMER EXPIRES
 337          *
 338          * Description: This function is called to get the number of ticks before a timer times out.
 339          *
 340          * Arguments  : ptmr          Is a pointer to the timer to obtain the remaining time from.
 341          *
 342          *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
 343          *                               OS_ERR_NONE
 344          *                               OS_ERR_TMR_INVALID        'ptmr' is a NULL pointer
 345          *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
 346          *                               OS_ERR_TMR_ISR            if the call was made from an ISR
 347          *                               OS_ERR_TMR_INACTIVE       'ptmr' points to a timer that is not active
 348          *                               OS_ERR_TMR_INVALID_STATE  the timer is in an invalid state
 349          *
 350          * Returns    : The time remaining for the timer to expire.  The time represents 'timer' increments.  In ot
             -her words, if
 351          *              OSTmr_Task() is signaled every 1/10 of a second then the returned value represents the numb
             -er of 1/10 of
 352          *              a second remaining before the timer expires.
 353          **********************************************************************************************************
             -**************
 354          */
 355          
 356          #if OS_TMR_EN > 0u
*** WARNING C322 IN LINE 356 OF Source\os_tmr.c: unknown identifier
              INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
                                      INT8U   *perr)
              {
                  INT32U  remain;
              
              
              #ifdef OS_SAFETY_CRITICAL
                  if (perr == (INT8U *)0) {
                      OS_SAFETY_CRITICAL_EXCEPTION();
                  }
              #endif
              
              #if OS_ARG_CHK_EN > 0u
                  if (ptmr == (OS_TMR *)0) {
                      *perr = OS_ERR_TMR_INVALID;
                      return (0u);
                  }
              #endif
                  if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                        
             -            */
                      *perr = OS_ERR_TMR_INVALID_TYPE;
                      return (0u);
                  }
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 10:39:23 PAGE 11  

                  if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR               
             -            */
                      *perr = OS_ERR_TMR_ISR;
                      return (0u);
                  }
                  OSSchedLock();
                  switch (ptmr->OSTmrState) {
                      case OS_TMR_STATE_RUNNING:
                           remain = ptmr->OSTmrMatch - OSTmrTime;    /* Determine how much time is left to timeout      
             -            */
                           OSSchedUnlock();
                           *perr  = OS_ERR_NONE;
                           return (remain);
              
                      case OS_TMR_STATE_STOPPED:                     /* It's assumed that the timer has not started yet 
             -            */
                           switch (ptmr->OSTmrOpt) {
                               case OS_TMR_OPT_PERIODIC:
                                    if (ptmr->OSTmrDly == 0u) {
                                        remain = ptmr->OSTmrPeriod;
                                    } else {
                                        remain = ptmr->OSTmrDly;
                                    }
                                    OSSchedUnlock();
                                    *perr  = OS_ERR_NONE;
                                    break;
              
                               case OS_TMR_OPT_ONE_SHOT:
                               default:
                                    remain = ptmr->OSTmrDly;
                                    OSSchedUnlock();
                                    *perr  = OS_ERR_NONE;
                                    break;
                           }
                           return (remain);
              
                      case OS_TMR_STATE_COMPLETED:                   /* Only ONE-SHOT that timed out can be in this stat
             -e           */
                           OSSchedUnlock();
                           *perr = OS_ERR_NONE;
                           return (0u);
              
                      case OS_TMR_STATE_UNUSED:
                           OSSchedUnlock();
                           *perr = OS_ERR_TMR_INACTIVE;
                           return (0u);
              
                      default:
                           OSSchedUnlock();
                           *perr = OS_ERR_TMR_INVALID_STATE;
                           return (0u);
                  }
              }
              #endif
 429          
 430          /*$PAGE*/
 431          /*
 432          **********************************************************************************************************
             -**************
 433          *                                    FIND OUT WHAT STATE A TIMER IS IN
 434          *
 435          * Description: This function is called to determine what state the timer is in:
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 10:39:23 PAGE 12  

 436          *
 437          *                  OS_TMR_STATE_UNUSED     the timer has not been created
 438          *                  OS_TMR_STATE_STOPPED    the timer has been created but has not been started or has been
             - stopped
 439          *                  OS_TMR_COMPLETED        the timer is in ONE-SHOT mode and has completed it's timeout
 440          *                  OS_TMR_RUNNING          the timer is currently running
 441          *
 442          * Arguments  : ptmr          Is a pointer to the desired timer
 443          *
 444          *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
 445          *                               OS_ERR_NONE
 446          *                               OS_ERR_TMR_INVALID        'ptmr' is a NULL pointer
 447          *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
 448          *                               OS_ERR_TMR_ISR            if the call was made from an ISR
 449          *                               OS_ERR_TMR_INACTIVE       'ptmr' points to a timer that is not active
 450          *                               OS_ERR_TMR_INVALID_STATE  if the timer is not in a valid state
 451          *
 452          * Returns    : The current state of the timer (see description).
 453          **********************************************************************************************************
             -**************
 454          */
 455          
 456          #if OS_TMR_EN > 0u
*** WARNING C322 IN LINE 456 OF Source\os_tmr.c: unknown identifier
              INT8U  OSTmrStateGet (OS_TMR  *ptmr,
                                    INT8U   *perr)
              {
                  INT8U  state;
              
              
              #ifdef OS_SAFETY_CRITICAL
                  if (perr == (INT8U *)0) {
                      OS_SAFETY_CRITICAL_EXCEPTION();
                  }
              #endif
              
              #if OS_ARG_CHK_EN > 0u
                  if (ptmr == (OS_TMR *)0) {
                      *perr = OS_ERR_TMR_INVALID;
                      return (0u);
                  }
              #endif
                  if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                        
             -            */
                      *perr = OS_ERR_TMR_INVALID_TYPE;
                      return (0u);
                  }
                  if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR               
             -            */
                      *perr = OS_ERR_TMR_ISR;
                      return (0u);
                  }
                  OSSchedLock();
                  state = ptmr->OSTmrState;
                  switch (state) {
                      case OS_TMR_STATE_UNUSED:
                      case OS_TMR_STATE_STOPPED:
                      case OS_TMR_STATE_COMPLETED:
                      case OS_TMR_STATE_RUNNING:
                           *perr = OS_ERR_NONE;
                           break;
              
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 10:39:23 PAGE 13  

                      default:
                           *perr = OS_ERR_TMR_INVALID_STATE;
                           break;
                  }
                  OSSchedUnlock();
                  return (state);
              }
              #endif
 501          
 502          /*$PAGE*/
 503          /*
 504          **********************************************************************************************************
             -**************
 505          *                                                   START A TIMER
 506          *
 507          * Description: This function is called by your application code to start a timer.
 508          *
 509          * Arguments  : ptmr          Is a pointer to an OS_TMR
 510          *
 511          *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
 512          *                               OS_ERR_NONE
 513          *                               OS_ERR_TMR_INVALID
 514          *                               OS_ERR_TMR_INVALID_TYPE    'ptmr'  is not pointing to an OS_TMR
 515          *                               OS_ERR_TMR_ISR             if the call was made from an ISR
 516          *                               OS_ERR_TMR_INACTIVE        if the timer was not created
 517          *                               OS_ERR_TMR_INVALID_STATE   the timer is in an invalid state
 518          *
 519          * Returns    : OS_TRUE    if the timer was started
 520          *              OS_FALSE   if an error was detected
 521          **********************************************************************************************************
             -**************
 522          */
 523          
 524          #if OS_TMR_EN > 0u
*** WARNING C322 IN LINE 524 OF Source\os_tmr.c: unknown identifier
              BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
                                   INT8U    *perr)
              {
              #ifdef OS_SAFETY_CRITICAL
                  if (perr == (INT8U *)0) {
                      OS_SAFETY_CRITICAL_EXCEPTION();
                  }
              #endif
              
              #if OS_ARG_CHK_EN > 0u
                  if (ptmr == (OS_TMR *)0) {
                      *perr = OS_ERR_TMR_INVALID;
                      return (OS_FALSE);
                  }
              #endif
                  if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                   
             -            */
                      *perr = OS_ERR_TMR_INVALID_TYPE;
                      return (OS_FALSE);
                  }
                  if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR          
             -            */
                      *perr  = OS_ERR_TMR_ISR;
                      return (OS_FALSE);
                  }
                  OSSchedLock();
                  switch (ptmr->OSTmrState) {
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 10:39:23 PAGE 14  

                      case OS_TMR_STATE_RUNNING:                          /* Restart the timer                          
             -            */
                           OSTmr_Unlink(ptmr);                            /* ... Stop the timer                         
             -            */
                           OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel              
             -            */
                           OSSchedUnlock();
                           *perr = OS_ERR_NONE;
                           return (OS_TRUE);
              
                      case OS_TMR_STATE_STOPPED:                          /* Start the timer                            
             -            */
                      case OS_TMR_STATE_COMPLETED:
                           OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel              
             -            */
                           OSSchedUnlock();
                           *perr = OS_ERR_NONE;
                           return (OS_TRUE);
              
                      case OS_TMR_STATE_UNUSED:                           /* Timer not created                          
             -            */
                           OSSchedUnlock();
                           *perr = OS_ERR_TMR_INACTIVE;
                           return (OS_FALSE);
              
                      default:
                           OSSchedUnlock();
                           *perr = OS_ERR_TMR_INVALID_STATE;
                           return (OS_FALSE);
                  }
              }
              #endif
 576          
 577          /*$PAGE*/
 578          /*
 579          **********************************************************************************************************
             -**************
 580          *                                                   STOP A TIMER
 581          *
 582          * Description: This function is called by your application code to stop a timer.
 583          *
 584          * Arguments  : ptmr          Is a pointer to the timer to stop.
 585          *
 586          *              opt           Allows you to specify an option to this functions which can be:
 587          *
 588          *                               OS_TMR_OPT_NONE          Do nothing special but stop the timer
 589          *                               OS_TMR_OPT_CALLBACK      Execute the callback function, pass it the callba
             -ck argument
 590          *                                                        specified when the timer was created.
 591          *                               OS_TMR_OPT_CALLBACK_ARG  Execute the callback function, pass it the callba
             -ck argument
 592          *                                                        specified in THIS function call
 593          *
 594          *              callback_arg  Is a pointer to a 'new' callback argument that can be passed to the callback 
             -function
 595          *                               instead of the timer's callback argument.  In other words, use 'callback_a
             -rg' passed in
 596          *                               THIS function INSTEAD of ptmr->OSTmrCallbackArg
 597          *
 598          *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
 599          *                               OS_ERR_NONE
 600          *                               OS_ERR_TMR_INVALID         'ptmr' is a NULL pointer
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 10:39:23 PAGE 15  

 601          *                               OS_ERR_TMR_INVALID_TYPE    'ptmr'  is not pointing to an OS_TMR
 602          *                               OS_ERR_TMR_ISR             if the function was called from an ISR
 603          *                               OS_ERR_TMR_INACTIVE        if the timer was not created
 604          *                               OS_ERR_TMR_INVALID_OPT     if you specified an invalid option for 'opt'
 605          *                               OS_ERR_TMR_STOPPED         if the timer was already stopped
 606          *                               OS_ERR_TMR_INVALID_STATE   the timer is in an invalid state
 607          *                               OS_ERR_TMR_NO_CALLBACK     if the timer does not have a callback function 
             -defined
 608          *
 609          * Returns    : OS_TRUE       If we stopped the timer (if the timer is already stopped, we also return OS_T
             -RUE)
 610          *              OS_FALSE      If not
 611          **********************************************************************************************************
             -**************
 612          */
 613          
 614          #if OS_TMR_EN > 0u
*** WARNING C322 IN LINE 614 OF Source\os_tmr.c: unknown identifier
              BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
                                  INT8U    opt,
                                  void    *callback_arg,
                                  INT8U   *perr)
              {
                  OS_TMR_CALLBACK  pfnct;
              
              
              #ifdef OS_SAFETY_CRITICAL
                  if (perr == (INT8U *)0) {
                      OS_SAFETY_CRITICAL_EXCEPTION();
                  }
              #endif
              
              #if OS_ARG_CHK_EN > 0u
                  if (ptmr == (OS_TMR *)0) {
                      *perr = OS_ERR_TMR_INVALID;
                      return (OS_FALSE);
                  }
              #endif
                  if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure             
             -            */
                      *perr = OS_ERR_TMR_INVALID_TYPE;
                      return (OS_FALSE);
                  }
                  if (OSIntNesting > 0u) {                                      /* See if trying to call from an ISR    
             -            */
                      *perr  = OS_ERR_TMR_ISR;
                      return (OS_FALSE);
                  }
                  OSSchedLock();
                  switch (ptmr->OSTmrState) {
                      case OS_TMR_STATE_RUNNING:
                           OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke      
             -            */
                           *perr = OS_ERR_NONE;
                           switch (opt) {
                               case OS_TMR_OPT_CALLBACK:
                                    pfnct = ptmr->OSTmrCallback;                /* Execute callback function if availabl
             -e ...       */
                                    if (pfnct != (OS_TMR_CALLBACK)0) {
                                        (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer 
             -was created */
                                    } else {
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 10:39:23 PAGE 16  

                                        *perr = OS_ERR_TMR_NO_CALLBACK;
                                    }
                                    break;
              
                               case OS_TMR_OPT_CALLBACK_ARG:
                                    pfnct = ptmr->OSTmrCallback;                /* Execute callback function if availabl
             -e ...       */
                                    if (pfnct != (OS_TMR_CALLBACK)0) {
                                        (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided
             - in call    */
                                    } else {
                                        *perr = OS_ERR_TMR_NO_CALLBACK;
                                    }
                                    break;
              
                               case OS_TMR_OPT_NONE:
                                    break;
              
                               default:
                                   *perr = OS_ERR_TMR_INVALID_OPT;
                                   break;
                           }
                           OSSchedUnlock();
                           return (OS_TRUE);
              
                      case OS_TMR_STATE_COMPLETED:                              /* Timer has already completed the ONE-S
             -HOT or ...  */
                      case OS_TMR_STATE_STOPPED:                                /* ... timer has not started yet.       
             -            */
                           OSSchedUnlock();
                           *perr = OS_ERR_TMR_STOPPED;
                           return (OS_TRUE);
              
                      case OS_TMR_STATE_UNUSED:                                 /* Timer was not created                
             -            */
                           OSSchedUnlock();
                           *perr = OS_ERR_TMR_INACTIVE;
                           return (OS_FALSE);
              
                      default:
                           OSSchedUnlock();
                           *perr = OS_ERR_TMR_INVALID_STATE;
                           return (OS_FALSE);
                  }
              }
              #endif
 695          
 696          /*$PAGE*/
 697          /*
 698          **********************************************************************************************************
             -**************
 699          *                                      SIGNAL THAT IT'S TIME TO UPDATE THE TIMERS
 700          *
 701          * Description: This function is typically called by the ISR that occurs at the timer tick rate and is used
             - to signal to
 702          *              OSTmr_Task() that it's time to update the timers.
 703          *
 704          * Arguments  : none
 705          *
 706          * Returns    : OS_ERR_NONE         The call was successful and the timer task was signaled.
 707          *              OS_ERR_SEM_OVF      If OSTmrSignal() was called more often than OSTmr_Task() can handle the
             - timers.
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 10:39:23 PAGE 17  

 708          *                                  This would indicate that your system is heavily loaded.
 709          *              OS_ERR_EVENT_TYPE   Unlikely you would get this error because the semaphore used for signal
             -ing is created
 710          *                                  by uC/OS-II.
 711          *              OS_ERR_PEVENT_NULL  Again, unlikely you would ever get this error because the semaphore use
             -d for signaling
 712          *                                  is created by uC/OS-II.
 713          **********************************************************************************************************
             -**************
 714          */
 715          
 716          #if OS_TMR_EN > 0u
*** WARNING C322 IN LINE 716 OF Source\os_tmr.c: unknown identifier
              INT8U  OSTmrSignal (void)
              {
                  INT8U  err;
              
              
                  err = OSSemPost(OSTmrSemSignal);
                  return (err);
              }
              #endif
 726          
 727          /*$PAGE*/
 728          /*
 729          **********************************************************************************************************
             -**************
 730          *                                               ALLOCATE AND FREE A TIMER
 731          *
 732          * Description: This function is called to allocate a timer.
 733          *
 734          * Arguments  : none
 735          *
 736          * Returns    : a pointer to a timer if one is available
 737          **********************************************************************************************************
             -**************
 738          */
 739          
 740          #if OS_TMR_EN > 0u
*** WARNING C322 IN LINE 740 OF Source\os_tmr.c: unknown identifier
              static  OS_TMR  *OSTmr_Alloc (void)
              {
                  OS_TMR *ptmr;
              
              
                  if (OSTmrFreeList == (OS_TMR *)0) {
                      return ((OS_TMR *)0);
                  }
                  ptmr            = (OS_TMR *)OSTmrFreeList;
                  OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
                  ptmr->OSTmrNext = (OS_TCB *)0;
                  ptmr->OSTmrPrev = (OS_TCB *)0;
                  OSTmrUsed++;
                  OSTmrFree--;
                  return (ptmr);
              }
              #endif
 758          
 759          
 760          /*
 761          **********************************************************************************************************
             -**************
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 10:39:23 PAGE 18  

 762          *                                             RETURN A TIMER TO THE FREE LIST
 763          *
 764          * Description: This function is called to return a timer object to the free list of timers.
 765          *
 766          * Arguments  : ptmr     is a pointer to the timer to free
 767          *
 768          * Returns    : none
 769          **********************************************************************************************************
             -**************
 770          */
 771          
 772          #if OS_TMR_EN > 0u
*** WARNING C322 IN LINE 772 OF Source\os_tmr.c: unknown identifier
              static  void  OSTmr_Free (OS_TMR *ptmr)
              {
                  ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                       
             -            */
                  ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
                  ptmr->OSTmrPeriod      = 0u;
                  ptmr->OSTmrMatch       = 0u;
                  ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
                  ptmr->OSTmrCallbackArg = (void *)0;
              #if OS_TMR_CFG_NAME_EN > 0u
                  ptmr->OSTmrName        = (INT8U *)(void *)"?";
              #endif
              
                  ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                        
             -            */
                  ptmr->OSTmrNext        = OSTmrFreeList;
                  OSTmrFreeList          = ptmr;
              
                  OSTmrUsed--;                                       /* Update timer object statistics                  
             -            */
                  OSTmrFree++;
              }
              #endif
 793          
 794          /*$PAGE*/
 795          /*
 796          **********************************************************************************************************
             -**************
 797          *                                                    INITIALIZATION
 798          *                                          INITIALIZE THE FREE LIST OF TIMERS
 799          *
 800          * Description: This function is called by OSInit() to initialize the free list of OS_TMRs.
 801          *
 802          * Arguments  : none
 803          *
 804          * Returns    : none
 805          **********************************************************************************************************
             -**************
 806          */
 807          
 808          #if OS_TMR_EN > 0u
*** WARNING C322 IN LINE 808 OF Source\os_tmr.c: unknown identifier
              void  OSTmr_Init (void)
              {
              #if OS_EVENT_NAME_EN > 0u
                  INT8U    err;
              #endif
                  INT16U   ix;
                  INT16U   ix_next;
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 10:39:23 PAGE 19  

                  OS_TMR  *ptmr1;
                  OS_TMR  *ptmr2;
              
              
                  OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs             
             -            */
                  OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel          
             -            */
              
                  for (ix = 0u; ix < (OS_TMR_CFG_MAX - 1u); ix++) {                   /* Init. list of free TMRs        
             -            */
                      ix_next = ix + 1u;
                      ptmr1 = &OSTmrTbl[ix];
                      ptmr2 = &OSTmrTbl[ix_next];
                      ptmr1->OSTmrType    = OS_TMR_TYPE;
                      ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive
             -            */
                      ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer             
             -            */
              #if OS_TMR_CFG_NAME_EN > 0u
                      ptmr1->OSTmrName    = (INT8U *)(void *)"?";
              #endif
                  }
                  ptmr1               = &OSTmrTbl[ix];
                  ptmr1->OSTmrType    = OS_TMR_TYPE;
                  ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive
             -            */
                  ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                    
             -            */
              #if OS_TMR_CFG_NAME_EN > 0u
                  ptmr1->OSTmrName    = (INT8U *)(void *)"?";
              #endif
                  OSTmrTime           = 0u;
                  OSTmrUsed           = 0u;
                  OSTmrFree           = OS_TMR_CFG_MAX;
                  OSTmrFreeList       = &OSTmrTbl[0];
                  OSTmrSem            = OSSemCreate(1u);
                  OSTmrSemSignal      = OSSemCreate(0u);
              
              #if OS_EVENT_NAME_EN > 0u                                               /* Assign names to semaphores     
             -            */
                  OSEventNameSet(OSTmrSem,       (INT8U *)(void *)"uC/OS-II TmrLock",   &err);
                  OSEventNameSet(OSTmrSemSignal, (INT8U *)(void *)"uC/OS-II TmrSignal", &err);
              #endif
              
                  OSTmr_InitTask();
              }
              #endif
 856          
 857          /*$PAGE*/
 858          /*
 859          **********************************************************************************************************
             -**************
 860          *                                          INITIALIZE THE TIMER MANAGEMENT TASK
 861          *
 862          * Description: This function is called by OSTmrInit() to create the timer management task.
 863          *                               * Arguments  : none
 864          *
 865          * Returns    : none
 866          **********************************************************************************************************
             -**************
 867          */
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 10:39:23 PAGE 20  

 868          
 869          #if OS_TMR_EN > 0u
*** WARNING C322 IN LINE 869 OF Source\os_tmr.c: unknown identifier
              static  void  OSTmr_InitTask (void)
              {
              #if OS_TASK_NAME_EN > 0u
                  INT8U  err;
              #endif
              
              
              #if OS_TASK_CREATE_EXT_EN > 0u
                  #if OS_STK_GROWTH == 1u
                  (void)OSTaskCreateExt(OSTmr_Task,
                                        (void *)0,                                       /* No arguments passed to OSTmr
             -Task()      */
                                        &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1u],        /* Set Top-Of-Stack            
             -            */
                                        OS_TASK_TMR_PRIO,
                                        OS_TASK_TMR_ID,
                                        &OSTmrTaskStk[0],                                /* Set Bottom-Of-Stack         
             -            */
                                        OS_TASK_TMR_STK_SIZE,
                                        (void *)0,                                       /* No TCB extension            
             -            */
                                        OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);      /* Enable stack checking + clea
             -r stack     */
                  #else
                  (void)OSTaskCreateExt(OSTmr_Task,
                                        (void *)0,                                       /* No arguments passed to OSTmr
             -Task()      */
                                        &OSTmrTaskStk[0],                                /* Set Top-Of-Stack            
             -            */
                                        OS_TASK_TMR_PRIO,
                                        OS_TASK_TMR_ID,
                                        &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1u],        /* Set Bottom-Of-Stack         
             -            */
                                        OS_TASK_TMR_STK_SIZE,
                                        (void *)0,                                       /* No TCB extension            
             -            */
                                        OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);      /* Enable stack checking + clea
             -r stack     */
                  #endif
              #else
                  #if OS_STK_GROWTH == 1u
                  (void)OSTaskCreate(OSTmr_Task,
                                     (void *)0,
                                     &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1u],
                                     OS_TASK_TMR_PRIO);
                  #else
                  (void)OSTaskCreate(OSTmr_Task,
                                     (void *)0,
                                     &OSTmrTaskStk[0],
                                     OS_TASK_TMR_PRIO);
                  #endif
              #endif
              
              #if OS_TASK_NAME_EN > 0u
                  OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)(void *)"uC/OS-II Tmr", &err);
              #endif
              }
              #endif
 918          
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 10:39:23 PAGE 21  

 919          /*$PAGE*/
 920          /*
 921          **********************************************************************************************************
             -**************
 922          *                                         INSERT A TIMER INTO THE TIMER WHEEL
 923          *
 924          * Description: This function is called to insert the timer into the timer wheel.  The timer is always inse
             -rted at the
 925          *              beginning of the list.
 926          *
 927          * Arguments  : ptmr          Is a pointer to the timer to insert.
 928          *
 929          *              type          Is either:
 930          *                               OS_TMR_LINK_PERIODIC    Means to re-insert the timer after a period expire
             -d
 931          *                               OS_TMR_LINK_DLY         Means to insert    the timer the first time
 932          *
 933          * Returns    : none
 934          **********************************************************************************************************
             -**************
 935          */
 936          
 937          #if OS_TMR_EN > 0u
*** WARNING C322 IN LINE 937 OF Source\os_tmr.c: unknown identifier
              static  void  OSTmr_Link (OS_TMR  *ptmr,
                                        INT8U    type)
              {
                  OS_TMR       *ptmr1;
                  OS_TMR_WHEEL *pspoke;
                  INT16U        spoke;
              
              
                  ptmr->OSTmrState = OS_TMR_STATE_RUNNING;
                  if (type == OS_TMR_LINK_PERIODIC) {                            /* Determine when timer will expire    
             -            */
                      ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
                  } else {
                      if (ptmr->OSTmrDly == 0u) {
                          ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
                      } else {
                          ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
                      }
                  }
                  spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
                  pspoke = &OSTmrWheelTbl[spoke];
              
                  if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel               
             -            */
                      pspoke->OSTmrFirst   = ptmr;
                      ptmr->OSTmrNext      = (OS_TMR *)0;
                      pspoke->OSTmrEntries = 1u;
                  } else {
                      ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke   
             -            */
                      pspoke->OSTmrFirst   = ptmr;
                      ptmr->OSTmrNext      = (void *)ptmr1;
                      ptmr1->OSTmrPrev     = (void *)ptmr;
                      pspoke->OSTmrEntries++;
                  }
                  ptmr->OSTmrPrev = (void *)0;                                   /* Timer always inserted as first node 
             -in list     */
              }
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 10:39:23 PAGE 22  

              #endif
 973          
 974          /*$PAGE*/
 975          /*
 976          **********************************************************************************************************
             -**************
 977          *                                         REMOVE A TIMER FROM THE TIMER WHEEL
 978          *
 979          * Description: This function is called to remove the timer from the timer wheel.
 980          *
 981          * Arguments  : ptmr          Is a pointer to the timer to remove.
 982          *
 983          * Returns    : none
 984          **********************************************************************************************************
             -**************
 985          */
 986          
 987          #if OS_TMR_EN > 0u
*** WARNING C322 IN LINE 987 OF Source\os_tmr.c: unknown identifier
              static  void  OSTmr_Unlink (OS_TMR *ptmr)
              {
                  OS_TMR        *ptmr1;
                  OS_TMR        *ptmr2;
                  OS_TMR_WHEEL  *pspoke;
                  INT16U         spoke;
              
              
                  spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
                  pspoke = &OSTmrWheelTbl[spoke];
              
                  if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning 
             -of list     */
                      ptmr1              = (OS_TMR *)ptmr->OSTmrNext;
                      pspoke->OSTmrFirst = (OS_TMR *)ptmr1;
                      if (ptmr1 != (OS_TMR *)0) {
                          ptmr1->OSTmrPrev = (void *)0;
                      }
                  } else {
                      ptmr1            = (OS_TMR *)ptmr->OSTmrPrev;       /* Remove timer from somewhere in the list    
             -            */
                      ptmr2            = (OS_TMR *)ptmr->OSTmrNext;
                      ptmr1->OSTmrNext = ptmr2;
                      if (ptmr2 != (OS_TMR *)0) {
                          ptmr2->OSTmrPrev = (void *)ptmr1;
                      }
                  }
                  ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
                  ptmr->OSTmrNext  = (void *)0;
                  ptmr->OSTmrPrev  = (void *)0;
                  pspoke->OSTmrEntries--;
              }
              #endif
1019          
1020          /*$PAGE*/
1021          /*
1022          **********************************************************************************************************
             -**************
1023          *                                                 TIMER MANAGEMENT TASK
1024          *
1025          * Description: This task is created by OSTmrInit().
1026          *
1027          * Arguments  : none
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 10:39:23 PAGE 23  

1028          *
1029          * Returns    : none
1030          **********************************************************************************************************
             -**************
1031          */
1032          
1033          #if OS_TMR_EN > 0u
*** WARNING C322 IN LINE 1033 OF Source\os_tmr.c: unknown identifier
              static  void  OSTmr_Task (void *p_arg)
              {
                  INT8U            err;
                  OS_TMR          *ptmr;
                  OS_TMR          *ptmr_next;
                  OS_TMR_CALLBACK  pfnct;
                  OS_TMR_WHEEL    *pspoke;
                  INT16U           spoke;
              
              
                  p_arg = p_arg;                                               /* Prevent compiler warning for not using
             - 'p_arg'    */
                  for (;;) {
                      OSSemPend(OSTmrSemSignal, 0u, &err);                     /* Wait for signal indicating time to upd
             -ate timers  */
                      OSSchedLock();
                      OSTmrTime++;                                             /* Increment the current time            
             -            */
                      spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry 
             -            */
                      pspoke = &OSTmrWheelTbl[spoke];
                      ptmr   = pspoke->OSTmrFirst;
                      while (ptmr != (OS_TMR *)0) {
                          ptmr_next = (OS_TMR *)ptmr->OSTmrNext;               /* Point to next timer to update because 
             -current ... */
                                                                               /* ... timer could get unlinked from the 
             -wheel.      */
                          if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires       
             -            */
                              OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke       
             -            */
                              if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
                                  OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in w
             -heel        */
                              } else {
                                  ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed 
             -            */
                              }
                              pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available
             -            */
                              if (pfnct != (OS_TMR_CALLBACK)0) {
                                  (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);
                              }
                          }
                          ptmr = ptmr_next;
                      }
                      OSSchedUnlock();
                  }
              }
              #endif
1073                                                                                                                                                       
             -                                                                                

C51 COMPILATION COMPLETE.  131 WARNING(S),  44 ERROR(S)
