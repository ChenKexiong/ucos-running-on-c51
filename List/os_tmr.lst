C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 14:58:00 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE OS_TMR
OBJECT MODULE PLACED IN .\Output\os_tmr.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE Source\os_tmr.c BROWSE INCDIR(.\Source) DEBUG OBJECTEXTEND PRINT(.\List\
                    -os_tmr.lst) TABS(2) OBJECT(.\Output\os_tmr.obj)

line level    source

   1          /*
   2          **********************************************************************************************************
             -**************
   3          *                                                uC/OS-II
   4          *                                          The Real-Time Kernel
   5          *                                            TIMER MANAGEMENT
   6          *
   7          *                              (c) Copyright 1992-2009, Micrium, Weston, FL
   8          *                                           All Rights Reserved
   9          *
  10          *
  11          * File    : OS_TMR.C
  12          * By      : Jean J. Labrosse
  13          * Version : V2.91
  14          *
  15          * LICENSING TERMS:
  16          * ---------------
  17          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
  18          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license
  19          * its use in your product. We provide ALL the source code for your convenience and to help you experience
  20          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
  21          * licensing fee.
  22          **********************************************************************************************************
             -**************
  23          */
  24          
  25          #include <ucos_ii.h>
*** WARNING C318 IN LINE 44 OF .\Source\ucos_ii.h: can't open file 'app_cfg.h'
  26          
  27          /*
  28          **********************************************************************************************************
             -**************
  29          *                                                        NOTES
  30          *
  31          * 1) Your application MUST define the following #define constants:
  32          *
  33          *    OS_TASK_TMR_PRIO          The priority of the Timer management task
  34          *    OS_TASK_TMR_STK_SIZE      The size     of the Timer management task's stack
  35          *
  36          * 2) You must call OSTmrSignal() to notify the Timer management task that it's time to update the timers.
  37          **********************************************************************************************************
             -**************
  38          */
  39          
  40          /*
  41          **********************************************************************************************************
             -**************
  42          *                                                     CONSTANTS
  43          **********************************************************************************************************
             -**************
  44          */
  45          
  46          #define  OS_TMR_LINK_DLY       0u
  47          #define  OS_TMR_LINK_PERIODIC  1u
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 14:58:00 PAGE 2   

  48          
  49          /*
  50          **********************************************************************************************************
             -**************
  51          *                                                  LOCAL PROTOTYPES
  52          **********************************************************************************************************
             -**************
  53          */
  54          
  55          #if OS_TMR_EN > 0u
  56          static  OS_TMR  *OSTmr_Alloc         (void);
  57          static  void     OSTmr_Free          (OS_TMR *ptmr);
  58          static  void     OSTmr_InitTask      (void);
  59          static  void     OSTmr_Link          (OS_TMR *ptmr, INT8U type);
  60          static  void     OSTmr_Unlink        (OS_TMR *ptmr);
  61          static  void     OSTmr_Task          (void   *p_arg);
  62          #endif
  63          
  64          /*$PAGE*/
  65          /*
  66          **********************************************************************************************************
             -**************
  67          *                                                   CREATE A TIMER
  68          *
  69          * Description: This function is called by your application code to create a timer.
  70          *
  71          * Arguments  : dly           Initial delay.
  72          *                            If the timer is configured for ONE-SHOT mode, this is the timeout used
  73          *                            If the timer is configured for PERIODIC mode, this is the first timeout to wa
             -it for
  74          *                               before the timer starts entering periodic mode
  75          *
  76          *              period        The 'period' being repeated for the timer.
  77          *                               If you specified 'OS_TMR_OPT_PERIODIC' as an option, when the timer expire
             -s, it will
  78          *                               automatically restart with the same period.
  79          *
  80          *              opt           Specifies either:
  81          *                               OS_TMR_OPT_ONE_SHOT       The timer counts down only once
  82          *                               OS_TMR_OPT_PERIODIC       The timer counts down and then reloads itself
  83          *
  84          *              callback      Is a pointer to a callback function that will be called when the timer expire
             -s.  The
  85          *                               callback function must be declared as follows:
  86          *
  87          *                               void MyCallback (OS_TMR *ptmr, void *p_arg);
  88          *
  89          *              callback_arg  Is an argument (a pointer) that is passed to the callback function when it is
             - called.
  90          *
  91          *              pname         Is a pointer to an ASCII string that is used to name the timer.  Names are us
             -eful for
  92          *                               debugging.
  93          *
  94          *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
  95          *                               OS_ERR_NONE
  96          *                               OS_ERR_TMR_INVALID_DLY     you specified an invalid delay
  97          *                               OS_ERR_TMR_INVALID_PERIOD  you specified an invalid period
  98          *                               OS_ERR_TMR_INVALID_OPT     you specified an invalid option
  99          *                               OS_ERR_TMR_ISR             if the call was made from an ISR
 100          *                               OS_ERR_TMR_NON_AVAIL       if there are no free timers from the timer pool
 101          *
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 14:58:00 PAGE 3   

 102          * Returns    : A pointer to an OS_TMR data structure.
 103          *              This is the 'handle' that your application will use to reference the timer created.
 104          **********************************************************************************************************
             -**************
 105          */
 106          
 107          #if OS_TMR_EN > 0u
 108          OS_TMR  *OSTmrCreate (INT32U           dly,
 109                                INT32U           period,
 110                                INT8U            opt,
 111                                OS_TMR_CALLBACK  callback,
 112                                void            *callback_arg,
 113                                INT8U           *pname,
 114                                INT8U           *perr)
 115          {
 116   1          OS_TMR   *ptmr;
 117   1      
 118   1      
 119   1      #ifdef OS_SAFETY_CRITICAL
                  if (perr == (INT8U *)0) {
                      OS_SAFETY_CRITICAL_EXCEPTION();
                  }
              #endif
 124   1      
 125   1      #ifdef OS_SAFETY_CRITICAL_IEC61508
                  if (OSSafetyCriticalStartFlag == OS_TRUE) {
                      OS_SAFETY_CRITICAL_EXCEPTION();
                  }
              #endif
 130   1      
 131   1      #if OS_ARG_CHK_EN > 0u
                  switch (opt) {                                          /* Validate arguments                         
             -            */
                      case OS_TMR_OPT_PERIODIC:
                           if (period == 0u) {
                               *perr = OS_ERR_TMR_INVALID_PERIOD;
                               return ((OS_TMR *)0);
                           }
                           break;
              
                      case OS_TMR_OPT_ONE_SHOT:
                           if (dly == 0u) {
                               *perr = OS_ERR_TMR_INVALID_DLY;
                               return ((OS_TMR *)0);
                           }
                           break;
              
                      default:
                           *perr = OS_ERR_TMR_INVALID_OPT;
                           return ((OS_TMR *)0);
                  }
              #endif
 152   1          if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR          
             -            */
 153   2              *perr  = OS_ERR_TMR_ISR;
 154   2              return ((OS_TMR *)0);
 155   2          }
 156   1          OSSchedLock();
 157   1          ptmr = OSTmr_Alloc();                                   /* Obtain a timer from the free pool          
             -            */
 158   1          if (ptmr == (OS_TMR *)0) {
 159   2              OSSchedUnlock();
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 14:58:00 PAGE 4   

 160   2              *perr = OS_ERR_TMR_NON_AVAIL;
 161   2              return ((OS_TMR *)0);
 162   2          }
 163   1          ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet     
             -            */
 164   1          ptmr->OSTmrDly         = dly;
 165   1          ptmr->OSTmrPeriod      = period;
 166   1          ptmr->OSTmrOpt         = opt;
 167   1          ptmr->OSTmrCallback    = callback;
 168   1          ptmr->OSTmrCallbackArg = callback_arg;
 169   1      #if OS_TMR_CFG_NAME_EN > 0u
 170   1          ptmr->OSTmrName        = pname;
 171   1      #endif
 172   1          OSSchedUnlock();
 173   1          *perr = OS_ERR_NONE;
 174   1          return (ptmr);
 175   1      }
 176          #endif
 177          
 178          /*$PAGE*/
 179          /*
 180          **********************************************************************************************************
             -**************
 181          *                                                   DELETE A TIMER
 182          *
 183          * Description: This function is called by your application code to delete a timer.
 184          *
 185          * Arguments  : ptmr          Is a pointer to the timer to stop and delete.
 186          *
 187          *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
 188          *                               OS_ERR_NONE
 189          *                               OS_ERR_TMR_INVALID        'ptmr'  is a NULL pointer
 190          *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
 191          *                               OS_ERR_TMR_ISR            if the function was called from an ISR
 192          *                               OS_ERR_TMR_INACTIVE       if the timer was not created
 193          *                               OS_ERR_TMR_INVALID_STATE  the timer is in an invalid state
 194          *
 195          * Returns    : OS_TRUE       If the call was successful
 196          *              OS_FALSE      If not
 197          **********************************************************************************************************
             -**************
 198          */
 199          
 200          #if OS_TMR_EN > 0u
 201          BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
 202                             INT8U   *perr)
 203          {
 204   1      #ifdef OS_SAFETY_CRITICAL
                  if (perr == (INT8U *)0) {
                      OS_SAFETY_CRITICAL_EXCEPTION();
                  }
              #endif
 209   1      
 210   1      #if OS_ARG_CHK_EN > 0u
                  if (ptmr == (OS_TMR *)0) {
                      *perr = OS_ERR_TMR_INVALID;
                      return (OS_FALSE);
                  }
              #endif
 216   1          if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                   
             -            */
 217   2              *perr = OS_ERR_TMR_INVALID_TYPE;
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 14:58:00 PAGE 5   

 218   2              return (OS_FALSE);
 219   2          }
 220   1          if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR          
             -            */
 221   2              *perr  = OS_ERR_TMR_ISR;
 222   2              return (OS_FALSE);
 223   2          }
 224   1          OSSchedLock();
 225   1          switch (ptmr->OSTmrState) {
 226   2              case OS_TMR_STATE_RUNNING:
 227   2                   OSTmr_Unlink(ptmr);                            /* Remove from current wheel spoke            
             -            */
 228   2                   OSTmr_Free(ptmr);                              /* Return timer to free list of timers        
             -            */
 229   2                   OSSchedUnlock();
 230   2                   *perr = OS_ERR_NONE;
 231   2                   return (OS_TRUE);
 232   2      
 233   2              case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...               
             -            */
 234   2              case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time  
             -            */
 235   2                   OSTmr_Free(ptmr);                              /* Return timer to free list of timers        
             -            */
 236   2                   OSSchedUnlock();
 237   2                   *perr = OS_ERR_NONE;
 238   2                   return (OS_TRUE);
 239   2      
 240   2              case OS_TMR_STATE_UNUSED:                           /* Already deleted                            
             -            */
 241   2                   OSSchedUnlock();
 242   2                   *perr = OS_ERR_TMR_INACTIVE;
 243   2                   return (OS_FALSE);
 244   2      
 245   2              default:
 246   2                   OSSchedUnlock();
 247   2                   *perr = OS_ERR_TMR_INVALID_STATE;
 248   2                   return (OS_FALSE);
 249   2          }
 250   1      }
 251          #endif
 252          
 253          /*$PAGE*/
 254          /*
 255          **********************************************************************************************************
             -**************
 256          *                                             GET THE NAME OF A TIMER
 257          *
 258          * Description: This function is called to obtain the name of a timer.
 259          *
 260          * Arguments  : ptmr          Is a pointer to the timer to obtain the name for
 261          *
 262          *              pdest         Is a pointer to pointer to where the name of the timer will be placed.
 263          *
 264          *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
 265          *                               OS_ERR_NONE               The call was successful
 266          *                               OS_ERR_TMR_INVALID_DEST   'pdest' is a NULL pointer
 267          *                               OS_ERR_TMR_INVALID        'ptmr'  is a NULL pointer
 268          *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
 269          *                               OS_ERR_NAME_GET_ISR       if the call was made from an ISR
 270          *                               OS_ERR_TMR_INACTIVE       'ptmr'  points to a timer that is not active
 271          *                               OS_ERR_TMR_INVALID_STATE  the timer is in an invalid state
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 14:58:00 PAGE 6   

 272          *
 273          * Returns    : The length of the string or 0 if the timer does not exist.
 274          **********************************************************************************************************
             -**************
 275          */
 276          
 277          #if OS_TMR_EN > 0u && OS_TMR_CFG_NAME_EN > 0u
 278          INT8U  OSTmrNameGet (OS_TMR   *ptmr,
 279                               INT8U   **pdest,
 280                               INT8U    *perr)
 281          {
 282   1          INT8U  len;
 283   1      
 284   1      
 285   1      #ifdef OS_SAFETY_CRITICAL
                  if (perr == (INT8U *)0) {
                      OS_SAFETY_CRITICAL_EXCEPTION();
                  }
              #endif
 290   1      
 291   1      #if OS_ARG_CHK_EN > 0u
                  if (pdest == (INT8U **)0) {
                      *perr = OS_ERR_TMR_INVALID_DEST;
                      return (0u);
                  }
                  if (ptmr == (OS_TMR *)0) {
                      *perr = OS_ERR_TMR_INVALID;
                      return (0u);
                  }
              #endif
 301   1          if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                        
             -            */
 302   2              *perr = OS_ERR_TMR_INVALID_TYPE;
 303   2              return (0u);
 304   2          }
 305   1          if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR               
             -            */
 306   2              *perr = OS_ERR_NAME_GET_ISR;
 307   2              return (0u);
 308   2          }
 309   1          OSSchedLock();
 310   1          switch (ptmr->OSTmrState) {
 311   2              case OS_TMR_STATE_RUNNING:
 312   2              case OS_TMR_STATE_STOPPED:
 313   2              case OS_TMR_STATE_COMPLETED:
 314   2                   *pdest = ptmr->OSTmrName;
 315   2                   len    = OS_StrLen(*pdest);
 316   2                   OSSchedUnlock();
 317   2                   *perr = OS_ERR_NONE;
 318   2                   return (len);
 319   2      
 320   2              case OS_TMR_STATE_UNUSED:                      /* Timer is not allocated                          
             -            */
 321   2                   OSSchedUnlock();
 322   2                   *perr = OS_ERR_TMR_INACTIVE;
 323   2                   return (0u);
 324   2      
 325   2              default:
 326   2                   OSSchedUnlock();
 327   2                   *perr = OS_ERR_TMR_INVALID_STATE;
 328   2                   return (0u);
 329   2          }
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 14:58:00 PAGE 7   

 330   1      }
 331          #endif
 332          
 333          /*$PAGE*/
 334          /*
 335          **********************************************************************************************************
             -**************
 336          *                                    GET HOW MUCH TIME IS LEFT BEFORE A TIMER EXPIRES
 337          *
 338          * Description: This function is called to get the number of ticks before a timer times out.
 339          *
 340          * Arguments  : ptmr          Is a pointer to the timer to obtain the remaining time from.
 341          *
 342          *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
 343          *                               OS_ERR_NONE
 344          *                               OS_ERR_TMR_INVALID        'ptmr' is a NULL pointer
 345          *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
 346          *                               OS_ERR_TMR_ISR            if the call was made from an ISR
 347          *                               OS_ERR_TMR_INACTIVE       'ptmr' points to a timer that is not active
 348          *                               OS_ERR_TMR_INVALID_STATE  the timer is in an invalid state
 349          *
 350          * Returns    : The time remaining for the timer to expire.  The time represents 'timer' increments.  In ot
             -her words, if
 351          *              OSTmr_Task() is signaled every 1/10 of a second then the returned value represents the numb
             -er of 1/10 of
 352          *              a second remaining before the timer expires.
 353          **********************************************************************************************************
             -**************
 354          */
 355          
 356          #if OS_TMR_EN > 0u
 357          INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
 358                                  INT8U   *perr)
 359          {
 360   1          INT32U  remain;
 361   1      
 362   1      
 363   1      #ifdef OS_SAFETY_CRITICAL
                  if (perr == (INT8U *)0) {
                      OS_SAFETY_CRITICAL_EXCEPTION();
                  }
              #endif
 368   1      
 369   1      #if OS_ARG_CHK_EN > 0u
                  if (ptmr == (OS_TMR *)0) {
                      *perr = OS_ERR_TMR_INVALID;
                      return (0u);
                  }
              #endif
 375   1          if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                        
             -            */
 376   2              *perr = OS_ERR_TMR_INVALID_TYPE;
 377   2              return (0u);
 378   2          }
 379   1          if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR               
             -            */
 380   2              *perr = OS_ERR_TMR_ISR;
 381   2              return (0u);
 382   2          }
 383   1          OSSchedLock();
 384   1          switch (ptmr->OSTmrState) {
 385   2              case OS_TMR_STATE_RUNNING:
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 14:58:00 PAGE 8   

 386   2                   remain = ptmr->OSTmrMatch - OSTmrTime;    /* Determine how much time is left to timeout      
             -            */
 387   2                   OSSchedUnlock();
 388   2                   *perr  = OS_ERR_NONE;
 389   2                   return (remain);
 390   2      
 391   2              case OS_TMR_STATE_STOPPED:                     /* It's assumed that the timer has not started yet 
             -            */
 392   2                   switch (ptmr->OSTmrOpt) {
 393   3                       case OS_TMR_OPT_PERIODIC:
 394   3                            if (ptmr->OSTmrDly == 0u) {
 395   4                                remain = ptmr->OSTmrPeriod;
 396   4                            } else {
 397   4                                remain = ptmr->OSTmrDly;
 398   4                            }
 399   3                            OSSchedUnlock();
 400   3                            *perr  = OS_ERR_NONE;
 401   3                            break;
 402   3      
 403   3                       case OS_TMR_OPT_ONE_SHOT:
 404   3                       default:
 405   3                            remain = ptmr->OSTmrDly;
 406   3                            OSSchedUnlock();
 407   3                            *perr  = OS_ERR_NONE;
 408   3                            break;
 409   3                   }
 410   2                   return (remain);
 411   2      
 412   2              case OS_TMR_STATE_COMPLETED:                   /* Only ONE-SHOT that timed out can be in this stat
             -e           */
 413   2                   OSSchedUnlock();
 414   2                   *perr = OS_ERR_NONE;
 415   2                   return (0u);
 416   2      
 417   2              case OS_TMR_STATE_UNUSED:
 418   2                   OSSchedUnlock();
 419   2                   *perr = OS_ERR_TMR_INACTIVE;
 420   2                   return (0u);
 421   2      
 422   2              default:
 423   2                   OSSchedUnlock();
 424   2                   *perr = OS_ERR_TMR_INVALID_STATE;
 425   2                   return (0u);
 426   2          }
 427   1      }
 428          #endif
 429          
 430          /*$PAGE*/
 431          /*
 432          **********************************************************************************************************
             -**************
 433          *                                    FIND OUT WHAT STATE A TIMER IS IN
 434          *
 435          * Description: This function is called to determine what state the timer is in:
 436          *
 437          *                  OS_TMR_STATE_UNUSED     the timer has not been created
 438          *                  OS_TMR_STATE_STOPPED    the timer has been created but has not been started or has been
             - stopped
 439          *                  OS_TMR_COMPLETED        the timer is in ONE-SHOT mode and has completed it's timeout
 440          *                  OS_TMR_RUNNING          the timer is currently running
 441          *
 442          * Arguments  : ptmr          Is a pointer to the desired timer
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 14:58:00 PAGE 9   

 443          *
 444          *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
 445          *                               OS_ERR_NONE
 446          *                               OS_ERR_TMR_INVALID        'ptmr' is a NULL pointer
 447          *                               OS_ERR_TMR_INVALID_TYPE   'ptmr'  is not pointing to an OS_TMR
 448          *                               OS_ERR_TMR_ISR            if the call was made from an ISR
 449          *                               OS_ERR_TMR_INACTIVE       'ptmr' points to a timer that is not active
 450          *                               OS_ERR_TMR_INVALID_STATE  if the timer is not in a valid state
 451          *
 452          * Returns    : The current state of the timer (see description).
 453          **********************************************************************************************************
             -**************
 454          */
 455          
 456          #if OS_TMR_EN > 0u
 457          INT8U  OSTmrStateGet (OS_TMR  *ptmr,
 458                                INT8U   *perr)
 459          {
 460   1          INT8U  state;
 461   1      
 462   1      
 463   1      #ifdef OS_SAFETY_CRITICAL
                  if (perr == (INT8U *)0) {
                      OS_SAFETY_CRITICAL_EXCEPTION();
                  }
              #endif
 468   1      
 469   1      #if OS_ARG_CHK_EN > 0u
                  if (ptmr == (OS_TMR *)0) {
                      *perr = OS_ERR_TMR_INVALID;
                      return (0u);
                  }
              #endif
 475   1          if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                        
             -            */
 476   2              *perr = OS_ERR_TMR_INVALID_TYPE;
 477   2              return (0u);
 478   2          }
 479   1          if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR               
             -            */
 480   2              *perr = OS_ERR_TMR_ISR;
 481   2              return (0u);
 482   2          }
 483   1          OSSchedLock();
 484   1          state = ptmr->OSTmrState;
 485   1          switch (state) {
 486   2              case OS_TMR_STATE_UNUSED:
 487   2              case OS_TMR_STATE_STOPPED:
 488   2              case OS_TMR_STATE_COMPLETED:
 489   2              case OS_TMR_STATE_RUNNING:
 490   2                   *perr = OS_ERR_NONE;
 491   2                   break;
 492   2      
 493   2              default:
 494   2                   *perr = OS_ERR_TMR_INVALID_STATE;
 495   2                   break;
 496   2          }
 497   1          OSSchedUnlock();
 498   1          return (state);
 499   1      }
 500          #endif
 501          
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 14:58:00 PAGE 10  

 502          /*$PAGE*/
 503          /*
 504          **********************************************************************************************************
             -**************
 505          *                                                   START A TIMER
 506          *
 507          * Description: This function is called by your application code to start a timer.
 508          *
 509          * Arguments  : ptmr          Is a pointer to an OS_TMR
 510          *
 511          *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
 512          *                               OS_ERR_NONE
 513          *                               OS_ERR_TMR_INVALID
 514          *                               OS_ERR_TMR_INVALID_TYPE    'ptmr'  is not pointing to an OS_TMR
 515          *                               OS_ERR_TMR_ISR             if the call was made from an ISR
 516          *                               OS_ERR_TMR_INACTIVE        if the timer was not created
 517          *                               OS_ERR_TMR_INVALID_STATE   the timer is in an invalid state
 518          *
 519          * Returns    : OS_TRUE    if the timer was started
 520          *              OS_FALSE   if an error was detected
 521          **********************************************************************************************************
             -**************
 522          */
 523          
 524          #if OS_TMR_EN > 0u
 525          BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
 526                               INT8U    *perr)
 527          {
 528   1      #ifdef OS_SAFETY_CRITICAL
                  if (perr == (INT8U *)0) {
                      OS_SAFETY_CRITICAL_EXCEPTION();
                  }
              #endif
 533   1      
 534   1      #if OS_ARG_CHK_EN > 0u
                  if (ptmr == (OS_TMR *)0) {
                      *perr = OS_ERR_TMR_INVALID;
                      return (OS_FALSE);
                  }
              #endif
 540   1          if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                   
             -            */
 541   2              *perr = OS_ERR_TMR_INVALID_TYPE;
 542   2              return (OS_FALSE);
 543   2          }
 544   1          if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR          
             -            */
 545   2              *perr  = OS_ERR_TMR_ISR;
 546   2              return (OS_FALSE);
 547   2          }
 548   1          OSSchedLock();
 549   1          switch (ptmr->OSTmrState) {
 550   2              case OS_TMR_STATE_RUNNING:                          /* Restart the timer                          
             -            */
 551   2                   OSTmr_Unlink(ptmr);                            /* ... Stop the timer                         
             -            */
 552   2                   OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel              
             -            */
 553   2                   OSSchedUnlock();
 554   2                   *perr = OS_ERR_NONE;
 555   2                   return (OS_TRUE);
 556   2      
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 14:58:00 PAGE 11  

 557   2              case OS_TMR_STATE_STOPPED:                          /* Start the timer                            
             -            */
 558   2              case OS_TMR_STATE_COMPLETED:
 559   2                   OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel              
             -            */
 560   2                   OSSchedUnlock();
 561   2                   *perr = OS_ERR_NONE;
 562   2                   return (OS_TRUE);
 563   2      
 564   2              case OS_TMR_STATE_UNUSED:                           /* Timer not created                          
             -            */
 565   2                   OSSchedUnlock();
 566   2                   *perr = OS_ERR_TMR_INACTIVE;
 567   2                   return (OS_FALSE);
 568   2      
 569   2              default:
 570   2                   OSSchedUnlock();
 571   2                   *perr = OS_ERR_TMR_INVALID_STATE;
 572   2                   return (OS_FALSE);
 573   2          }
 574   1      }
 575          #endif
 576          
 577          /*$PAGE*/
 578          /*
 579          **********************************************************************************************************
             -**************
 580          *                                                   STOP A TIMER
 581          *
 582          * Description: This function is called by your application code to stop a timer.
 583          *
 584          * Arguments  : ptmr          Is a pointer to the timer to stop.
 585          *
 586          *              opt           Allows you to specify an option to this functions which can be:
 587          *
 588          *                               OS_TMR_OPT_NONE          Do nothing special but stop the timer
 589          *                               OS_TMR_OPT_CALLBACK      Execute the callback function, pass it the callba
             -ck argument
 590          *                                                        specified when the timer was created.
 591          *                               OS_TMR_OPT_CALLBACK_ARG  Execute the callback function, pass it the callba
             -ck argument
 592          *                                                        specified in THIS function call
 593          *
 594          *              callback_arg  Is a pointer to a 'new' callback argument that can be passed to the callback 
             -function
 595          *                               instead of the timer's callback argument.  In other words, use 'callback_a
             -rg' passed in
 596          *                               THIS function INSTEAD of ptmr->OSTmrCallbackArg
 597          *
 598          *              perr          Is a pointer to an error code.  '*perr' will contain one of the following:
 599          *                               OS_ERR_NONE
 600          *                               OS_ERR_TMR_INVALID         'ptmr' is a NULL pointer
 601          *                               OS_ERR_TMR_INVALID_TYPE    'ptmr'  is not pointing to an OS_TMR
 602          *                               OS_ERR_TMR_ISR             if the function was called from an ISR
 603          *                               OS_ERR_TMR_INACTIVE        if the timer was not created
 604          *                               OS_ERR_TMR_INVALID_OPT     if you specified an invalid option for 'opt'
 605          *                               OS_ERR_TMR_STOPPED         if the timer was already stopped
 606          *                               OS_ERR_TMR_INVALID_STATE   the timer is in an invalid state
 607          *                               OS_ERR_TMR_NO_CALLBACK     if the timer does not have a callback function 
             -defined
 608          *
 609          * Returns    : OS_TRUE       If we stopped the timer (if the timer is already stopped, we also return OS_T
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 14:58:00 PAGE 12  

             -RUE)
 610          *              OS_FALSE      If not
 611          **********************************************************************************************************
             -**************
 612          */
 613          
 614          #if OS_TMR_EN > 0u
 615          BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
 616                              INT8U    opt,
 617                              void    *callback_arg,
 618                              INT8U   *perr)
 619          {
 620   1          OS_TMR_CALLBACK  pfnct;
 621   1      
 622   1      
 623   1      #ifdef OS_SAFETY_CRITICAL
                  if (perr == (INT8U *)0) {
                      OS_SAFETY_CRITICAL_EXCEPTION();
                  }
              #endif
 628   1      
 629   1      #if OS_ARG_CHK_EN > 0u
                  if (ptmr == (OS_TMR *)0) {
                      *perr = OS_ERR_TMR_INVALID;
                      return (OS_FALSE);
                  }
              #endif
 635   1          if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure             
             -            */
 636   2              *perr = OS_ERR_TMR_INVALID_TYPE;
 637   2              return (OS_FALSE);
 638   2          }
 639   1          if (OSIntNesting > 0u) {                                      /* See if trying to call from an ISR    
             -            */
 640   2              *perr  = OS_ERR_TMR_ISR;
 641   2              return (OS_FALSE);
 642   2          }
 643   1          OSSchedLock();
 644   1          switch (ptmr->OSTmrState) {
 645   2              case OS_TMR_STATE_RUNNING:
 646   2                   OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke      
             -            */
 647   2                   *perr = OS_ERR_NONE;
 648   2                   switch (opt) {
 649   3                       case OS_TMR_OPT_CALLBACK:
 650   3                            pfnct = ptmr->OSTmrCallback;                /* Execute callback function if availabl
             -e ...       */
 651   3                            if (pfnct != (OS_TMR_CALLBACK)0) {
 652   4                                (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer 
             -was created */
*** ERROR C212 IN LINE 652 OF Source\os_tmr.c: indirect call: parameters do not fit within registers
 653   4                            } else {
 654   4                                *perr = OS_ERR_TMR_NO_CALLBACK;
 655   4                            }
 656   3                            break;
 657   3      
 658   3                       case OS_TMR_OPT_CALLBACK_ARG:
 659   3                            pfnct = ptmr->OSTmrCallback;                /* Execute callback function if availabl
             -e ...       */
 660   3                            if (pfnct != (OS_TMR_CALLBACK)0) {
 661   4                                (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided
             - in call    */
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 14:58:00 PAGE 13  

*** ERROR C212 IN LINE 661 OF Source\os_tmr.c: indirect call: parameters do not fit within registers
 662   4                            } else {
 663   4                                *perr = OS_ERR_TMR_NO_CALLBACK;
 664   4                            }
 665   3                            break;
 666   3      
 667   3                       case OS_TMR_OPT_NONE:
 668   3                            break;
 669   3      
 670   3                       default:
 671   3                           *perr = OS_ERR_TMR_INVALID_OPT;
 672   3                           break;
 673   3                   }
 674   2                   OSSchedUnlock();
 675   2                   return (OS_TRUE);
 676   2      
 677   2              case OS_TMR_STATE_COMPLETED:                              /* Timer has already completed the ONE-S
             -HOT or ...  */
 678   2              case OS_TMR_STATE_STOPPED:                                /* ... timer has not started yet.       
             -            */
 679   2                   OSSchedUnlock();
 680   2                   *perr = OS_ERR_TMR_STOPPED;
 681   2                   return (OS_TRUE);
 682   2      
 683   2              case OS_TMR_STATE_UNUSED:                                 /* Timer was not created                
             -            */
 684   2                   OSSchedUnlock();
 685   2                   *perr = OS_ERR_TMR_INACTIVE;
 686   2                   return (OS_FALSE);
 687   2      
 688   2              default:
 689   2                   OSSchedUnlock();
 690   2                   *perr = OS_ERR_TMR_INVALID_STATE;
 691   2                   return (OS_FALSE);
 692   2          }
 693   1      }
 694          #endif
 695          
 696          /*$PAGE*/
 697          /*
 698          **********************************************************************************************************
             -**************
 699          *                                      SIGNAL THAT IT'S TIME TO UPDATE THE TIMERS
 700          *
 701          * Description: This function is typically called by the ISR that occurs at the timer tick rate and is used
             - to signal to
 702          *              OSTmr_Task() that it's time to update the timers.
 703          *
 704          * Arguments  : none
 705          *
 706          * Returns    : OS_ERR_NONE         The call was successful and the timer task was signaled.
 707          *              OS_ERR_SEM_OVF      If OSTmrSignal() was called more often than OSTmr_Task() can handle the
             - timers.
 708          *                                  This would indicate that your system is heavily loaded.
 709          *              OS_ERR_EVENT_TYPE   Unlikely you would get this error because the semaphore used for signal
             -ing is created
 710          *                                  by uC/OS-II.
 711          *              OS_ERR_PEVENT_NULL  Again, unlikely you would ever get this error because the semaphore use
             -d for signaling
 712          *                                  is created by uC/OS-II.
 713          **********************************************************************************************************
             -**************
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 14:58:00 PAGE 14  

 714          */
 715          
 716          #if OS_TMR_EN > 0u
 717          INT8U  OSTmrSignal (void)
 718          {
 719   1          INT8U  err;
 720   1      
 721   1      
 722   1          err = OSSemPost(OSTmrSemSignal);
 723   1          return (err);
 724   1      }
 725          #endif
 726          
 727          /*$PAGE*/
 728          /*
 729          **********************************************************************************************************
             -**************
 730          *                                               ALLOCATE AND FREE A TIMER
 731          *
 732          * Description: This function is called to allocate a timer.
 733          *
 734          * Arguments  : none
 735          *
 736          * Returns    : a pointer to a timer if one is available
 737          **********************************************************************************************************
             -**************
 738          */
 739          
 740          #if OS_TMR_EN > 0u
 741          static  OS_TMR  *OSTmr_Alloc (void)
 742          {
 743   1          OS_TMR *ptmr;
 744   1      
 745   1      
 746   1          if (OSTmrFreeList == (OS_TMR *)0) {
 747   2              return ((OS_TMR *)0);
 748   2          }
 749   1          ptmr            = (OS_TMR *)OSTmrFreeList;
 750   1          OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
 751   1          ptmr->OSTmrNext = (OS_TCB *)0;
 752   1          ptmr->OSTmrPrev = (OS_TCB *)0;
 753   1          OSTmrUsed++;
 754   1          OSTmrFree--;
 755   1          return (ptmr);
 756   1      }
 757          #endif
 758          
 759          
 760          /*
 761          **********************************************************************************************************
             -**************
 762          *                                             RETURN A TIMER TO THE FREE LIST
 763          *
 764          * Description: This function is called to return a timer object to the free list of timers.
 765          *
 766          * Arguments  : ptmr     is a pointer to the timer to free
 767          *
 768          * Returns    : none
 769          **********************************************************************************************************
             -**************
 770          */
 771          
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 14:58:00 PAGE 15  

 772          #if OS_TMR_EN > 0u
 773          static  void  OSTmr_Free (OS_TMR *ptmr)
 774          {
 775   1          ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                       
             -            */
 776   1          ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
 777   1          ptmr->OSTmrPeriod      = 0u;
 778   1          ptmr->OSTmrMatch       = 0u;
 779   1          ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
 780   1          ptmr->OSTmrCallbackArg = (void *)0;
 781   1      #if OS_TMR_CFG_NAME_EN > 0u
 782   1          ptmr->OSTmrName        = (INT8U *)(void *)"?";
 783   1      #endif
 784   1      
 785   1          ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                        
             -            */
 786   1          ptmr->OSTmrNext        = OSTmrFreeList;
 787   1          OSTmrFreeList          = ptmr;
 788   1      
 789   1          OSTmrUsed--;                                       /* Update timer object statistics                  
             -            */
 790   1          OSTmrFree++;
 791   1      }
 792          #endif
 793          
 794          /*$PAGE*/
 795          /*
 796          **********************************************************************************************************
             -**************
 797          *                                                    INITIALIZATION
 798          *                                          INITIALIZE THE FREE LIST OF TIMERS
 799          *
 800          * Description: This function is called by OSInit() to initialize the free list of OS_TMRs.
 801          *
 802          * Arguments  : none
 803          *
 804          * Returns    : none
 805          **********************************************************************************************************
             -**************
 806          */
 807          
 808          #if OS_TMR_EN > 0u
 809          void  OSTmr_Init (void)
 810          {
 811   1      #if OS_EVENT_NAME_EN > 0u
 812   1          INT8U    err;
 813   1      #endif
 814   1          INT16U   ix;
 815   1          INT16U   ix_next;
 816   1          OS_TMR  *ptmr1;
 817   1          OS_TMR  *ptmr2;
 818   1      
 819   1      
 820   1          OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs             
             -            */
 821   1          OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel          
             -            */
 822   1      
 823   1          for (ix = 0u; ix < (OS_TMR_CFG_MAX - 1u); ix++) {                   /* Init. list of free TMRs        
             -            */
 824   2              ix_next = ix + 1u;
 825   2              ptmr1 = &OSTmrTbl[ix];
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 14:58:00 PAGE 16  

 826   2              ptmr2 = &OSTmrTbl[ix_next];
 827   2              ptmr1->OSTmrType    = OS_TMR_TYPE;
 828   2              ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive
             -            */
 829   2              ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer             
             -            */
 830   2      #if OS_TMR_CFG_NAME_EN > 0u
 831   2              ptmr1->OSTmrName    = (INT8U *)(void *)"?";
 832   2      #endif
 833   2          }
 834   1          ptmr1               = &OSTmrTbl[ix];
 835   1          ptmr1->OSTmrType    = OS_TMR_TYPE;
 836   1          ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive
             -            */
 837   1          ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                    
             -            */
 838   1      #if OS_TMR_CFG_NAME_EN > 0u
 839   1          ptmr1->OSTmrName    = (INT8U *)(void *)"?";
 840   1      #endif
 841   1          OSTmrTime           = 0u;
 842   1          OSTmrUsed           = 0u;
 843   1          OSTmrFree           = OS_TMR_CFG_MAX;
 844   1          OSTmrFreeList       = &OSTmrTbl[0];
 845   1          OSTmrSem            = OSSemCreate(1u);
 846   1          OSTmrSemSignal      = OSSemCreate(0u);
 847   1      
 848   1      #if OS_EVENT_NAME_EN > 0u                                               /* Assign names to semaphores     
             -            */
 849   1          OSEventNameSet(OSTmrSem,       (INT8U *)(void *)"uC/OS-II TmrLock",   &err);
 850   1          OSEventNameSet(OSTmrSemSignal, (INT8U *)(void *)"uC/OS-II TmrSignal", &err);
 851   1      #endif
 852   1      
 853   1          OSTmr_InitTask();
 854   1      }
 855          #endif
 856          
 857          /*$PAGE*/
 858          /*
 859          **********************************************************************************************************
             -**************
 860          *                                          INITIALIZE THE TIMER MANAGEMENT TASK
 861          *
 862          * Description: This function is called by OSTmrInit() to create the timer management task.
 863          *                               * Arguments  : none
 864          *
 865          * Returns    : none
 866          **********************************************************************************************************
             -**************
 867          */
 868          
 869          #if OS_TMR_EN > 0u
 870          static  void  OSTmr_InitTask (void)
 871          {
 872   1      #if OS_TASK_NAME_EN > 0u
 873   1          INT8U  err;
 874   1      #endif
 875   1      
 876   1      
 877   1      #if OS_TASK_CREATE_EXT_EN > 0u
 878   1          #if OS_STK_GROWTH == 1u
*** WARNING C322 IN LINE 878 OF Source\os_tmr.c: unknown identifier
                  (void)OSTaskCreateExt(OSTmr_Task,
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 14:58:00 PAGE 17  

                                        (void *)0,                                       /* No arguments passed to OSTmr
             -Task()      */
                                        &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1u],        /* Set Top-Of-Stack            
             -            */
                                        OS_TASK_TMR_PRIO,
                                        OS_TASK_TMR_ID,
                                        &OSTmrTaskStk[0],                                /* Set Bottom-Of-Stack         
             -            */
                                        OS_TASK_TMR_STK_SIZE,
                                        (void *)0,                                       /* No TCB extension            
             -            */
                                        OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);      /* Enable stack checking + clea
             -r stack     */
                  #else
 889   1          (void)OSTaskCreateExt(OSTmr_Task,
 890   1                                (void *)0,                                       /* No arguments passed to OSTmr
             -Task()      */
 891   1                                &OSTmrTaskStk[0],                                /* Set Top-Of-Stack            
             -            */
 892   1                                OS_TASK_TMR_PRIO,
*** ERROR C202 IN LINE 892 OF Source\os_tmr.c: 'OS_TASK_TMR_PRIO': undefined identifier
 893   1                                OS_TASK_TMR_ID,
 894   1                                &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1u],        /* Set Bottom-Of-Stack         
             -            */
 895   1                                OS_TASK_TMR_STK_SIZE,
 896   1                                (void *)0,                                       /* No TCB extension            
             -            */
 897   1                                OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);      /* Enable stack checking + clea
             -r stack     */
 898   1          #endif
 899   1      #else
                  #if OS_STK_GROWTH == 1u
                  (void)OSTaskCreate(OSTmr_Task,
                                     (void *)0,
                                     &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1u],
                                     OS_TASK_TMR_PRIO);
                  #else
                  (void)OSTaskCreate(OSTmr_Task,
                                     (void *)0,
                                     &OSTmrTaskStk[0],
                                     OS_TASK_TMR_PRIO);
                  #endif
              #endif
 912   1      
 913   1      #if OS_TASK_NAME_EN > 0u
 914   1          OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)(void *)"uC/OS-II Tmr", &err);
*** ERROR C202 IN LINE 914 OF Source\os_tmr.c: 'OS_TASK_TMR_PRIO': undefined identifier
 915   1      #endif
 916   1      }
 917          #endif
 918          
 919          /*$PAGE*/
 920          /*
 921          **********************************************************************************************************
             -**************
 922          *                                         INSERT A TIMER INTO THE TIMER WHEEL
 923          *
 924          * Description: This function is called to insert the timer into the timer wheel.  The timer is always inse
             -rted at the
 925          *              beginning of the list.
 926          *
 927          * Arguments  : ptmr          Is a pointer to the timer to insert.
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 14:58:00 PAGE 18  

 928          *
 929          *              type          Is either:
 930          *                               OS_TMR_LINK_PERIODIC    Means to re-insert the timer after a period expire
             -d
 931          *                               OS_TMR_LINK_DLY         Means to insert    the timer the first time
 932          *
 933          * Returns    : none
 934          **********************************************************************************************************
             -**************
 935          */
 936          
 937          #if OS_TMR_EN > 0u
 938          static  void  OSTmr_Link (OS_TMR  *ptmr,
 939                                    INT8U    type)
 940          {
 941   1          OS_TMR       *ptmr1;
 942   1          OS_TMR_WHEEL *pspoke;
 943   1          INT16U        spoke;
 944   1      
 945   1      
 946   1          ptmr->OSTmrState = OS_TMR_STATE_RUNNING;
 947   1          if (type == OS_TMR_LINK_PERIODIC) {                            /* Determine when timer will expire    
             -            */
 948   2              ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
 949   2          } else {
 950   2              if (ptmr->OSTmrDly == 0u) {
 951   3                  ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
 952   3              } else {
 953   3                  ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
 954   3              }
 955   2          }
 956   1          spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
 957   1          pspoke = &OSTmrWheelTbl[spoke];
 958   1      
 959   1          if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel               
             -            */
 960   2              pspoke->OSTmrFirst   = ptmr;
 961   2              ptmr->OSTmrNext      = (OS_TMR *)0;
 962   2              pspoke->OSTmrEntries = 1u;
 963   2          } else {
 964   2              ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke   
             -            */
 965   2              pspoke->OSTmrFirst   = ptmr;
 966   2              ptmr->OSTmrNext      = (void *)ptmr1;
 967   2              ptmr1->OSTmrPrev     = (void *)ptmr;
 968   2              pspoke->OSTmrEntries++;
 969   2          }
 970   1          ptmr->OSTmrPrev = (void *)0;                                   /* Timer always inserted as first node 
             -in list     */
 971   1      }
 972          #endif
 973          
 974          /*$PAGE*/
 975          /*
 976          **********************************************************************************************************
             -**************
 977          *                                         REMOVE A TIMER FROM THE TIMER WHEEL
 978          *
 979          * Description: This function is called to remove the timer from the timer wheel.
 980          *
 981          * Arguments  : ptmr          Is a pointer to the timer to remove.
 982          *
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 14:58:00 PAGE 19  

 983          * Returns    : none
 984          **********************************************************************************************************
             -**************
 985          */
 986          
 987          #if OS_TMR_EN > 0u
 988          static  void  OSTmr_Unlink (OS_TMR *ptmr)
 989          {
 990   1          OS_TMR        *ptmr1;
 991   1          OS_TMR        *ptmr2;
 992   1          OS_TMR_WHEEL  *pspoke;
 993   1          INT16U         spoke;
 994   1      
 995   1      
 996   1          spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
 997   1          pspoke = &OSTmrWheelTbl[spoke];
 998   1      
 999   1          if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning 
             -of list     */
1000   2              ptmr1              = (OS_TMR *)ptmr->OSTmrNext;
1001   2              pspoke->OSTmrFirst = (OS_TMR *)ptmr1;
1002   2              if (ptmr1 != (OS_TMR *)0) {
1003   3                  ptmr1->OSTmrPrev = (void *)0;
1004   3              }
1005   2          } else {
1006   2              ptmr1            = (OS_TMR *)ptmr->OSTmrPrev;       /* Remove timer from somewhere in the list    
             -            */
1007   2              ptmr2            = (OS_TMR *)ptmr->OSTmrNext;
1008   2              ptmr1->OSTmrNext = ptmr2;
1009   2              if (ptmr2 != (OS_TMR *)0) {
1010   3                  ptmr2->OSTmrPrev = (void *)ptmr1;
1011   3              }
1012   2          }
1013   1          ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
1014   1          ptmr->OSTmrNext  = (void *)0;
1015   1          ptmr->OSTmrPrev  = (void *)0;
1016   1          pspoke->OSTmrEntries--;
1017   1      }
1018          #endif
1019          
1020          /*$PAGE*/
1021          /*
1022          **********************************************************************************************************
             -**************
1023          *                                                 TIMER MANAGEMENT TASK
1024          *
1025          * Description: This task is created by OSTmrInit().
1026          *
1027          * Arguments  : none
1028          *
1029          * Returns    : none
1030          **********************************************************************************************************
             -**************
1031          */
1032          
1033          #if OS_TMR_EN > 0u
1034          static  void  OSTmr_Task (void *p_arg)
1035          {
1036   1          INT8U            err;
1037   1          OS_TMR          *ptmr;
1038   1          OS_TMR          *ptmr_next;
1039   1          OS_TMR_CALLBACK  pfnct;
C51 COMPILER V9.51   OS_TMR                                                                02/25/2015 14:58:00 PAGE 20  

1040   1          OS_TMR_WHEEL    *pspoke;
1041   1          INT16U           spoke;
1042   1      
1043   1      
1044   1          p_arg = p_arg;                                               /* Prevent compiler warning for not using
             - 'p_arg'    */
1045   1          for (;;) {
1046   2              OSSemPend(OSTmrSemSignal, 0u, &err);                     /* Wait for signal indicating time to upd
             -ate timers  */
1047   2              OSSchedLock();
1048   2              OSTmrTime++;                                             /* Increment the current time            
             -            */
1049   2              spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry 
             -            */
1050   2              pspoke = &OSTmrWheelTbl[spoke];
1051   2              ptmr   = pspoke->OSTmrFirst;
1052   2              while (ptmr != (OS_TMR *)0) {
1053   3                  ptmr_next = (OS_TMR *)ptmr->OSTmrNext;               /* Point to next timer to update because 
             -current ... */
1054   3                                                                       /* ... timer could get unlinked from the 
             -wheel.      */
1055   3                  if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires       
             -            */
1056   4                      OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke       
             -            */
1057   4                      if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
1058   5                          OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in w
             -heel        */
1059   5                      } else {
1060   5                          ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed 
             -            */
1061   5                      }
1062   4                      pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available
             -            */
1063   4                      if (pfnct != (OS_TMR_CALLBACK)0) {
1064   5                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);
*** ERROR C212 IN LINE 1064 OF Source\os_tmr.c: indirect call: parameters do not fit within registers
1065   5                      }
1066   4                  }
1067   3                  ptmr = ptmr_next;
1068   3              }
1069   2              OSSchedUnlock();
1070   2          }
1071   1      }
1072          #endif
1073                                                                                                                                                       
             -                                                                                

C51 COMPILATION COMPLETE.  2 WARNING(S),  5 ERROR(S)
