C51 COMPILER V9.51   OS_MUTEX                                                              02/25/2015 14:57:59 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE OS_MUTEX
OBJECT MODULE PLACED IN .\Output\os_mutex.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE Source\os_mutex.c BROWSE INCDIR(.\Source) DEBUG OBJECTEXTEND PRINT(.\Lis
                    -t\os_mutex.lst) TABS(2) OBJECT(.\Output\os_mutex.obj)

line level    source

   1          /*
   2          *********************************************************************************************************
   3          *                                                uC/OS-II
   4          *                                          The Real-Time Kernel
   5          *                                  MUTUAL EXCLUSION SEMAPHORE MANAGEMENT
   6          *
   7          *                              (c) Copyright 1992-2009, Micrium, Weston, FL
   8          *                                           All Rights Reserved
   9          *
  10          * File    : OS_MUTEX.C
  11          * By      : Jean J. Labrosse
  12          * Version : V2.91
  13          *
  14          * LICENSING TERMS:
  15          * ---------------
  16          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
  17          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license
  18          * its use in your product. We provide ALL the source code for your convenience and to help you experience
  19          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
  20          * licensing fee.
  21          *********************************************************************************************************
  22          */
  23          
  24          #ifndef  OS_MASTER_FILE
  25          #include <ucos_ii.h>
*** WARNING C318 IN LINE 44 OF .\Source\ucos_ii.h: can't open file 'app_cfg.h'
  26          #endif
  27          
  28          
  29          #if OS_MUTEX_EN > 0u
  30          /*
  31          *********************************************************************************************************
  32          *                                            LOCAL CONSTANTS
  33          *********************************************************************************************************
  34          */
  35          
  36          #define  OS_MUTEX_KEEP_LOWER_8   ((INT16U)0x00FFu)
  37          #define  OS_MUTEX_KEEP_UPPER_8   ((INT16U)0xFF00u)
  38          
  39          #define  OS_MUTEX_AVAILABLE      ((INT16U)0x00FFu)
  40          
  41          /*
  42          *********************************************************************************************************
  43          *                                            LOCAL CONSTANTS
  44          *********************************************************************************************************
  45          */
  46          
  47          static  void  OSMutex_RdyAtPrio(OS_TCB *ptcb, INT8U prio);
  48          
  49          /*$PAGE*/
  50          /*
  51          *********************************************************************************************************
  52          *                                   ACCEPT MUTUAL EXCLUSION SEMAPHORE
  53          *
C51 COMPILER V9.51   OS_MUTEX                                                              02/25/2015 14:57:59 PAGE 2   

  54          * Description: This  function checks the mutual exclusion semaphore to see if a resource is available.
  55          *              Unlike OSMutexPend(), OSMutexAccept() does not suspend the calling task if the resource is
  56          *              not available or the event did not occur.
  57          *
  58          * Arguments  : pevent     is a pointer to the event control block
  59          *
  60          *              perr       is a pointer to an error code which will be returned to your application:
  61          *                            OS_ERR_NONE         if the call was successful.
  62          *                            OS_ERR_EVENT_TYPE   if 'pevent' is not a pointer to a mutex
  63          *                            OS_ERR_PEVENT_NULL  'pevent' is a NULL pointer
  64          *                            OS_ERR_PEND_ISR     if you called this function from an ISR
  65          *                            OS_ERR_PIP_LOWER    If the priority of the task that owns the Mutex is
  66          *                                                HIGHER (i.e. a lower number) than the PIP.  This error
  67          *                                                indicates that you did not set the PIP higher (lower
  68          *                                                number) than ALL the tasks that compete for the Mutex.
  69          *                                                Unfortunately, this is something that could not be
  70          *                                                detected when the Mutex is created because we don't know
  71          *                                                what tasks will be using the Mutex.
  72          *
  73          * Returns    : == OS_TRUE    if the resource is available, the mutual exclusion semaphore is acquired
  74          *              == OS_FALSE   a) if the resource is not available
  75          *                            b) you didn't pass a pointer to a mutual exclusion semaphore
  76          *                            c) you called this function from an ISR
  77          *
  78          * Warning(s) : This function CANNOT be called from an ISR because mutual exclusion semaphores are
  79          *              intended to be used by tasks only.
  80          *********************************************************************************************************
  81          */
  82          
  83          #if OS_MUTEX_ACCEPT_EN > 0u
  84          BOOLEAN  OSMutexAccept (OS_EVENT  *pevent,
  85                                  INT8U     *perr)
  86          {
  87   1          INT8U      pip;                                    /* Priority Inheritance Priority (PIP)          */
  88   1      #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
*** WARNING C322 IN LINE 88 OF Source\os_mutex.c: unknown identifier
                  OS_CPU_SR  cpu_sr = 0u;
              #endif
  91   1      
  92   1      
  93   1      
  94   1      #ifdef OS_SAFETY_CRITICAL
                  if (perr == (INT8U *)0) {
                      OS_SAFETY_CRITICAL_EXCEPTION();
                  }
              #endif
  99   1      
 100   1      #if OS_ARG_CHK_EN > 0u
                  if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
                      *perr = OS_ERR_PEVENT_NULL;
                      return (OS_FALSE);
                  }
              #endif
 106   1          if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
 107   2              *perr = OS_ERR_EVENT_TYPE;
 108   2              return (OS_FALSE);
 109   2          }
 110   1          if (OSIntNesting > 0u) {                           /* Make sure it's not called from an ISR        */
 111   2              *perr = OS_ERR_PEND_ISR;
 112   2              return (OS_FALSE);
 113   2          }
 114   1          OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
C51 COMPILER V9.51   OS_MUTEX                                                              02/25/2015 14:57:59 PAGE 3   

 115   1          pip = (INT8U)(pevent->OSEventCnt >> 8u);           /* Get PIP from mutex                           */
 116   1          if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
 117   2              pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
 118   2              pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
 119   2              pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
 120   2              if (OSTCBCur->OSTCBPrio <= pip) {              /*      PIP 'must' have a SMALLER prio ...      */
 121   3                  OS_EXIT_CRITICAL();                        /*      ... than current task!                  */
 122   3                  *perr = OS_ERR_PIP_LOWER;
 123   3              } else {
 124   3                  OS_EXIT_CRITICAL();
 125   3                  *perr = OS_ERR_NONE;
 126   3              }
 127   2              return (OS_TRUE);
 128   2          }
 129   1          OS_EXIT_CRITICAL();
 130   1          *perr = OS_ERR_NONE;
 131   1          return (OS_FALSE);
 132   1      }
 133          #endif
 134          
 135          /*$PAGE*/
 136          /*
 137          *********************************************************************************************************
 138          *                                  CREATE A MUTUAL EXCLUSION SEMAPHORE
 139          *
 140          * Description: This function creates a mutual exclusion semaphore.
 141          *
 142          * Arguments  : prio          is the priority to use when accessing the mutual exclusion semaphore.  In
 143          *                            other words, when the semaphore is acquired and a higher priority task
 144          *                            attempts to obtain the semaphore then the priority of the task owning the
 145          *                            semaphore is raised to this priority.  It is assumed that you will specify
 146          *                            a priority that is LOWER in value than ANY of the tasks competing for the
 147          *                            mutex.
 148          *
 149          *              perr          is a pointer to an error code which will be returned to your application:
 150          *                               OS_ERR_NONE         if the call was successful.
 151          *                               OS_ERR_CREATE_ISR   if you attempted to create a MUTEX from an ISR
 152          *                               OS_ERR_PRIO_EXIST   if a task at the priority inheritance priority
 153          *                                                   already exist.
 154          *                               OS_ERR_PEVENT_NULL  No more event control blocks available.
 155          *                               OS_ERR_PRIO_INVALID if the priority you specify is higher that the
 156          *                                                   maximum allowed (i.e. > OS_LOWEST_PRIO)
 157          *
 158          * Returns    : != (void *)0  is a pointer to the event control clock (OS_EVENT) associated with the
 159          *                            created mutex.
 160          *              == (void *)0  if an error is detected.
 161          *
 162          * Note(s)    : 1) The LEAST significant 8 bits of '.OSEventCnt' are used to hold the priority number
 163          *                 of the task owning the mutex or 0xFF if no task owns the mutex.
 164          *
 165          *              2) The MOST  significant 8 bits of '.OSEventCnt' are used to hold the priority number
 166          *                 to use to reduce priority inversion.
 167          *********************************************************************************************************
 168          */
 169          
 170          OS_EVENT  *OSMutexCreate (INT8U   prio,
 171                                    INT8U  *perr)
 172          {
 173   1          OS_EVENT  *pevent;
 174   1      #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
*** WARNING C322 IN LINE 174 OF Source\os_mutex.c: unknown identifier
                  OS_CPU_SR  cpu_sr = 0u;
C51 COMPILER V9.51   OS_MUTEX                                                              02/25/2015 14:57:59 PAGE 4   

              #endif
 177   1      
 178   1      
 179   1      
 180   1      #ifdef OS_SAFETY_CRITICAL
                  if (perr == (INT8U *)0) {
                      OS_SAFETY_CRITICAL_EXCEPTION();
                  }
              #endif
 185   1      
 186   1      #ifdef OS_SAFETY_CRITICAL_IEC61508
                  if (OSSafetyCriticalStartFlag == OS_TRUE) {
                      OS_SAFETY_CRITICAL_EXCEPTION();
                  }
              #endif
 191   1      
 192   1      #if OS_ARG_CHK_EN > 0u
                  if (prio >= OS_LOWEST_PRIO) {                          /* Validate PIP                             */
                      *perr = OS_ERR_PRIO_INVALID;
                      return ((OS_EVENT *)0);
                  }
              #endif
 198   1          if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
 199   2              *perr = OS_ERR_CREATE_ISR;                         /* ... can't CREATE mutex from an ISR       */
 200   2              return ((OS_EVENT *)0);
 201   2          }
 202   1          OS_ENTER_CRITICAL();
 203   1          if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {               /* Mutex priority must not already exist    */
 204   2              OS_EXIT_CRITICAL();                                /* Task already exist at priority ...       */
 205   2              *perr = OS_ERR_PRIO_EXIST;                         /* ... inheritance priority                 */
 206   2              return ((OS_EVENT *)0);
 207   2          }
 208   1          OSTCBPrioTbl[prio] = OS_TCB_RESERVED;                  /* Reserve the table entry                  */
 209   1          pevent             = OSEventFreeList;                  /* Get next free event control block        */
 210   1          if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available              */
 211   2              OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* No, Release the table entry              */
 212   2              OS_EXIT_CRITICAL();
 213   2              *perr              = OS_ERR_PEVENT_NULL;           /* No more event control blocks             */
 214   2              return (pevent);
 215   2          }
 216   1          OSEventFreeList        = (OS_EVENT *)OSEventFreeList->OSEventPtr;   /* Adjust the free list        */
 217   1          OS_EXIT_CRITICAL();
 218   1          pevent->OSEventType    = OS_EVENT_TYPE_MUTEX;
 219   1          pevent->OSEventCnt     = (INT16U)((INT16U)prio << 8u) | OS_MUTEX_AVAILABLE; /* Resource is avail.  */
 220   1          pevent->OSEventPtr     = (void *)0;                                 /* No task owning the mutex    */
 221   1      #if OS_EVENT_NAME_EN > 0u
 222   1          pevent->OSEventName    = (INT8U *)(void *)"?";
 223   1      #endif
 224   1          OS_EventWaitListInit(pevent);
 225   1          *perr                  = OS_ERR_NONE;
 226   1          return (pevent);
 227   1      }
 228          
 229          /*$PAGE*/
 230          /*
 231          *********************************************************************************************************
 232          *                                          DELETE A MUTEX
 233          *
 234          * Description: This function deletes a mutual exclusion semaphore and readies all tasks pending on the it.
 235          *
 236          * Arguments  : pevent        is a pointer to the event control block associated with the desired mutex.
 237          *
C51 COMPILER V9.51   OS_MUTEX                                                              02/25/2015 14:57:59 PAGE 5   

 238          *              opt           determines delete options as follows:
 239          *                            opt == OS_DEL_NO_PEND   Delete mutex ONLY if no task pending
 240          *                            opt == OS_DEL_ALWAYS    Deletes the mutex even if tasks are waiting.
 241          *                                                    In this case, all the tasks pending will be readied.
 242          *
 243          *              perr          is a pointer to an error code that can contain one of the following values:
 244          *                            OS_ERR_NONE             The call was successful and the mutex was deleted
 245          *                            OS_ERR_DEL_ISR          If you attempted to delete the MUTEX from an ISR
 246          *                            OS_ERR_INVALID_OPT      An invalid option was specified
 247          *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the mutex
 248          *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mutex
 249          *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
 250          *
 251          * Returns    : pevent        upon error
 252          *              (OS_EVENT *)0 if the mutex was successfully deleted.
 253          *
 254          * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
 255          *                 the mutex MUST check the return code of OSMutexPend().
 256          *
 257          *              2) This call can potentially disable interrupts for a long time.  The interrupt disable
 258          *                 time is directly proportional to the number of tasks waiting on the mutex.
 259          *
 260          *              3) Because ALL tasks pending on the mutex will be readied, you MUST be careful because the
 261          *                 resource(s) will no longer be guarded by the mutex.
 262          *
 263          *              4) IMPORTANT: In the 'OS_DEL_ALWAYS' case, we assume that the owner of the Mutex (if there
 264          *                            is one) is ready-to-run and is thus NOT pending on another kernel object or
 265          *                            has delayed itself.  In other words, if a task owns the mutex being deleted,
 266          *                            that task will be made ready-to-run at its original priority.
 267          *********************************************************************************************************
 268          */
 269          
 270          #if OS_MUTEX_DEL_EN > 0u
 271          OS_EVENT  *OSMutexDel (OS_EVENT  *pevent,
 272                                 INT8U      opt,
 273                                 INT8U     *perr)
 274          {
 275   1          BOOLEAN    tasks_waiting;
 276   1          OS_EVENT  *pevent_return;
 277   1          INT8U      pip;                                        /* Priority inheritance priority            */
 278   1          INT8U      prio;
 279   1          OS_TCB    *ptcb;
 280   1      #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
*** WARNING C322 IN LINE 280 OF Source\os_mutex.c: unknown identifier
                  OS_CPU_SR  cpu_sr = 0u;
              #endif
 283   1      
 284   1      
 285   1      
 286   1      #ifdef OS_SAFETY_CRITICAL
                  if (perr == (INT8U *)0) {
                      OS_SAFETY_CRITICAL_EXCEPTION();
                  }
              #endif
 291   1      
 292   1      #if OS_ARG_CHK_EN > 0u
                  if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                      *perr = OS_ERR_PEVENT_NULL;
                      return (pevent);
                  }
              #endif
 298   1          if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
C51 COMPILER V9.51   OS_MUTEX                                                              02/25/2015 14:57:59 PAGE 6   

 299   2              *perr = OS_ERR_EVENT_TYPE;
 300   2              return (pevent);
 301   2          }
 302   1          if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
 303   2              *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
 304   2              return (pevent);
 305   2          }
 306   1          OS_ENTER_CRITICAL();
 307   1          if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on mutex        */
 308   2              tasks_waiting = OS_TRUE;                           /* Yes                                      */
 309   2          } else {
 310   2              tasks_waiting = OS_FALSE;                          /* No                                       */
 311   2          }
 312   1          switch (opt) {
 313   2              case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING --- */
 314   2                   if (tasks_waiting == OS_FALSE) {
 315   3      #if OS_EVENT_NAME_EN > 0u
 316   3                       pevent->OSEventName = (INT8U *)(void *)"?";
 317   3      #endif
 318   3                       pip                 = (INT8U)(pevent->OSEventCnt >> 8u);
 319   3                       OSTCBPrioTbl[pip]   = (OS_TCB *)0;        /* Free up the PIP                          */
 320   3                       pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
 321   3                       pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
 322   3                       pevent->OSEventCnt  = 0u;
 323   3                       OSEventFreeList     = pevent;
 324   3                       OS_EXIT_CRITICAL();
 325   3                       *perr               = OS_ERR_NONE;
 326   3                       pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
 327   3                   } else {
 328   3                       OS_EXIT_CRITICAL();
 329   3                       *perr               = OS_ERR_TASK_WAITING;
 330   3                       pevent_return       = pevent;
 331   3                   }
 332   2                   break;
 333   2      
 334   2              case OS_DEL_ALWAYS:                                /* ALWAYS DELETE THE MUTEX ---------------- */
 335   2                   pip  = (INT8U)(pevent->OSEventCnt >> 8u);                    /* Get PIP of mutex          */
 336   2                   prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original prio */
 337   2                   ptcb = (OS_TCB *)pevent->OSEventPtr;
 338   2                   if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
 339   3                       if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
 340   4                           OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
 341   4                       }
 342   3                   }
 343   2                   while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for mutex        */
 344   3                       (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
 345   3                   }
 346   2      #if OS_EVENT_NAME_EN > 0u
 347   2                   pevent->OSEventName = (INT8U *)(void *)"?";
 348   2      #endif
 349   2                   pip                 = (INT8U)(pevent->OSEventCnt >> 8u);
 350   2                   OSTCBPrioTbl[pip]   = (OS_TCB *)0;            /* Free up the PIP                          */
 351   2                   pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
 352   2                   pevent->OSEventPtr  = OSEventFreeList;        /* Return Event Control Block to free list  */
 353   2                   pevent->OSEventCnt  = 0u;
 354   2                   OSEventFreeList     = pevent;                 /* Get next free event control block        */
 355   2                   OS_EXIT_CRITICAL();
 356   2                   if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 357   3                       OS_Sched();                               /* Find highest priority task ready to run  */
 358   3                   }
 359   2                   *perr         = OS_ERR_NONE;
 360   2                   pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted                   */
C51 COMPILER V9.51   OS_MUTEX                                                              02/25/2015 14:57:59 PAGE 7   

 361   2                   break;
 362   2      
 363   2              default:
 364   2                   OS_EXIT_CRITICAL();
 365   2                   *perr         = OS_ERR_INVALID_OPT;
 366   2                   pevent_return = pevent;
 367   2                   break;
 368   2          }
 369   1          return (pevent_return);
 370   1      }
 371          #endif
 372          
 373          /*$PAGE*/
 374          /*
 375          *********************************************************************************************************
 376          *                                  PEND ON MUTUAL EXCLUSION SEMAPHORE
 377          *
 378          * Description: This function waits for a mutual exclusion semaphore.
 379          *
 380          * Arguments  : pevent        is a pointer to the event control block associated with the desired
 381          *                            mutex.
 382          *
 383          *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
 384          *                            wait for the resource up to the amount of time specified by this argument.
 385          *                            If you specify 0, however, your task will wait forever at the specified
 386          *                            mutex or, until the resource becomes available.
 387          *
 388          *              perr          is a pointer to where an error message will be deposited.  Possible error
 389          *                            messages are:
 390          *                               OS_ERR_NONE        The call was successful and your task owns the mutex
 391          *                               OS_ERR_TIMEOUT     The mutex was not available within the specified 'timeo
             -ut'.
 392          *                               OS_ERR_PEND_ABORT  The wait on the mutex was aborted.
 393          *                               OS_ERR_EVENT_TYPE  If you didn't pass a pointer to a mutex
 394          *                               OS_ERR_PEVENT_NULL 'pevent' is a NULL pointer
 395          *                               OS_ERR_PEND_ISR    If you called this function from an ISR and the result
 396          *                                                  would lead to a suspension.
 397          *                               OS_ERR_PIP_LOWER   If the priority of the task that owns the Mutex is
 398          *                                                  HIGHER (i.e. a lower number) than the PIP.  This error
 399          *                                                  indicates that you did not set the PIP higher (lower
 400          *                                                  number) than ALL the tasks that compete for the Mutex.
 401          *                                                  Unfortunately, this is something that could not be
 402          *                                                  detected when the Mutex is created because we don't kno
             -w
 403          *                                                  what tasks will be using the Mutex.
 404          *                               OS_ERR_PEND_LOCKED If you called this function when the scheduler is locke
             -d
 405          *
 406          * Returns    : none
 407          *
 408          * Note(s)    : 1) The task that owns the Mutex MUST NOT pend on any other event while it owns the mutex.
 409          *
 410          *              2) You MUST NOT change the priority of the task that owns the mutex
 411          *********************************************************************************************************
 412          */
 413          
 414          void  OSMutexPend (OS_EVENT  *pevent,
 415                             INT32U     timeout,
 416                             INT8U     *perr)
 417          {
 418   1          INT8U      pip;                                        /* Priority Inheritance Priority (PIP)      */
 419   1          INT8U      mprio;                                      /* Mutex owner priority                     */
C51 COMPILER V9.51   OS_MUTEX                                                              02/25/2015 14:57:59 PAGE 8   

 420   1          BOOLEAN    rdy;                                        /* Flag indicating task was ready           */
 421   1          OS_TCB    *ptcb;
 422   1          OS_EVENT  *pevent2;
 423   1          INT8U      y;
 424   1      #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
*** WARNING C322 IN LINE 424 OF Source\os_mutex.c: unknown identifier
                  OS_CPU_SR  cpu_sr = 0u;
              #endif
 427   1      
 428   1      
 429   1      
 430   1      #ifdef OS_SAFETY_CRITICAL
                  if (perr == (INT8U *)0) {
                      OS_SAFETY_CRITICAL_EXCEPTION();
                  }
              #endif
 435   1      
 436   1      #if OS_ARG_CHK_EN > 0u
                  if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                      *perr = OS_ERR_PEVENT_NULL;
                      return;
                  }
              #endif
 442   1          if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
 443   2              *perr = OS_ERR_EVENT_TYPE;
 444   2              return;
 445   2          }
 446   1          if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
 447   2              *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
 448   2              return;
 449   2          }
 450   1          if (OSLockNesting > 0u) {                              /* See if called with scheduler locked ...  */
 451   2              *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
 452   2              return;
 453   2          }
 454   1      /*$PAGE*/
 455   1          OS_ENTER_CRITICAL();
 456   1          pip = (INT8U)(pevent->OSEventCnt >> 8u);               /* Get PIP from mutex                       */
 457   1                                                                 /* Is Mutex available?                      */
 458   1          if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
 459   2              pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
 460   2              pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
 461   2              pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB       */
 462   2              if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
 463   3                  OS_EXIT_CRITICAL();                            /*      ... than current task!              */
 464   3                  *perr = OS_ERR_PIP_LOWER;
 465   3              } else {
 466   3                  OS_EXIT_CRITICAL();
 467   3                  *perr = OS_ERR_NONE;
 468   3              }
 469   2              return;
 470   2          }
 471   1          mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* No, Get priority of mutex owner   */
 472   1          ptcb  = (OS_TCB *)(pevent->OSEventPtr);                       /*     Point to TCB of mutex owner   */
 473   1          if (ptcb->OSTCBPrio > pip) {                                  /*     Need to promote prio of owner?*/
 474   2              if (mprio > OSTCBCur->OSTCBPrio) {
 475   3                  y = ptcb->OSTCBY;
 476   3                  if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0u) {          /*     See if mutex owner is ready   */
 477   4                      OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;         /*     Yes, Remove owner from Rdy ...*/
 478   4                      if (OSRdyTbl[y] == 0u) {                          /*          ... list at current prio */
 479   5                          OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
 480   5                      }
C51 COMPILER V9.51   OS_MUTEX                                                              02/25/2015 14:57:59 PAGE 9   

 481   4                      rdy = OS_TRUE;
 482   4                  } else {
 483   4                      pevent2 = ptcb->OSTCBEventPtr;
 484   4                      if (pevent2 != (OS_EVENT *)0) {                   /* Remove from event wait list       */
 485   5                          y = ptcb->OSTCBY;
 486   5                          pevent2->OSEventTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;
 487   5                          if (pevent2->OSEventTbl[y] == 0u) {
 488   6                              pevent2->OSEventGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
 489   6                          }
 490   5                      }
 491   4                      rdy = OS_FALSE;                            /* No                                       */
 492   4                  }
 493   3                  ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
 494   3      #if OS_LOWEST_PRIO <= 63u
 495   3                  ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3u);
 496   3                  ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07u);
 497   3      #else
                          ptcb->OSTCBY    = (INT8U)((INT8U)(ptcb->OSTCBPrio >> 4u) & 0xFFu);
                          ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x0Fu);
              #endif
 501   3                  ptcb->OSTCBBitY = (OS_PRIO)(1uL << ptcb->OSTCBY);
 502   3                  ptcb->OSTCBBitX = (OS_PRIO)(1uL << ptcb->OSTCBX);
 503   3      
 504   3                  if (rdy == OS_TRUE) {                          /* If task was ready at owner's priority ...*/
 505   4                      OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.       */
 506   4                      OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 507   4                  } else {
 508   4                      pevent2 = ptcb->OSTCBEventPtr;
 509   4                      if (pevent2 != (OS_EVENT *)0) {            /* Add to event wait list                   */
 510   5                          pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
 511   5                          pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 512   5                      }
 513   4                  }
 514   3                  OSTCBPrioTbl[pip] = ptcb;
 515   3              }
 516   2          }
 517   1          OSTCBCur->OSTCBStat     |= OS_STAT_MUTEX;         /* Mutex not available, pend current task        */
 518   1          OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 519   1          OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB           */
 520   1          OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
 521   1          OS_EXIT_CRITICAL();
 522   1          OS_Sched();                                       /* Find next highest priority task ready         */
 523   1          OS_ENTER_CRITICAL();
 524   1          switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
 525   2              case OS_STAT_PEND_OK:
 526   2                   *perr = OS_ERR_NONE;
 527   2                   break;
 528   2      
 529   2              case OS_STAT_PEND_ABORT:
 530   2                   *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted getting mutex        */
 531   2                   break;
 532   2      
 533   2              case OS_STAT_PEND_TO:
 534   2              default:
 535   2                   OS_EventTaskRemove(OSTCBCur, pevent);
 536   2                   *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get mutex within TO   */
 537   2                   break;
 538   2          }
 539   1          OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
 540   1          OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
 541   1          OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
 542   1      #if (OS_EVENT_MULTI_EN > 0u)
C51 COMPILER V9.51   OS_MUTEX                                                              02/25/2015 14:57:59 PAGE 10  

 543   1          OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 544   1      #endif
 545   1          OS_EXIT_CRITICAL();
 546   1      }
 547          /*$PAGE*/
 548          /*
 549          *********************************************************************************************************
 550          *                                  POST TO A MUTUAL EXCLUSION SEMAPHORE
 551          *
 552          * Description: This function signals a mutual exclusion semaphore
 553          *
 554          * Arguments  : pevent              is a pointer to the event control block associated with the desired
 555          *                                  mutex.
 556          *
 557          * Returns    : OS_ERR_NONE             The call was successful and the mutex was signaled.
 558          *              OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mutex
 559          *              OS_ERR_PEVENT_NULL      'pevent' is a NULL pointer
 560          *              OS_ERR_POST_ISR         Attempted to post from an ISR (not valid for MUTEXes)
 561          *              OS_ERR_NOT_MUTEX_OWNER  The task that did the post is NOT the owner of the MUTEX.
 562          *              OS_ERR_PIP_LOWER        If the priority of the new task that owns the Mutex is
 563          *                                      HIGHER (i.e. a lower number) than the PIP.  This error
 564          *                                      indicates that you did not set the PIP higher (lower
 565          *                                      number) than ALL the tasks that compete for the Mutex.
 566          *                                      Unfortunately, this is something that could not be
 567          *                                      detected when the Mutex is created because we don't know
 568          *                                      what tasks will be using the Mutex.
 569          *********************************************************************************************************
 570          */
 571          
 572          INT8U  OSMutexPost (OS_EVENT *pevent)
 573          {
 574   1          INT8U      pip;                                   /* Priority inheritance priority                 */
 575   1          INT8U      prio;
 576   1      #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
*** WARNING C322 IN LINE 576 OF Source\os_mutex.c: unknown identifier
                  OS_CPU_SR  cpu_sr = 0u;
              #endif
 579   1      
 580   1      
 581   1      
 582   1          if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
 583   2              return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR              */
 584   2          }
 585   1      #if OS_ARG_CHK_EN > 0u
                  if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                      return (OS_ERR_PEVENT_NULL);
                  }
              #endif
 590   1          if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
 591   2              return (OS_ERR_EVENT_TYPE);
 592   2          }
 593   1          OS_ENTER_CRITICAL();
 594   1          pip  = (INT8U)(pevent->OSEventCnt >> 8u);         /* Get priority inheritance priority of mutex    */
 595   1          prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
 596   1          if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
 597   2              OS_EXIT_CRITICAL();
 598   2              return (OS_ERR_NOT_MUTEX_OWNER);
 599   2          }
 600   1          if (OSTCBCur->OSTCBPrio == pip) {                 /* Did we have to raise current task's priority? */
 601   2              OSMutex_RdyAtPrio(OSTCBCur, prio);            /* Restore the task's original priority          */
 602   2          }
 603   1          OSTCBPrioTbl[pip] = OS_TCB_RESERVED;              /* Reserve table entry                           */
C51 COMPILER V9.51   OS_MUTEX                                                              02/25/2015 14:57:59 PAGE 11  

 604   1          if (pevent->OSEventGrp != 0u) {                   /* Any task waiting for the mutex?               */
 605   2                                                            /* Yes, Make HPT waiting for mutex ready         */
 606   2              prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
 607   2              pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
 608   2              pevent->OSEventCnt |= prio;
 609   2              pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
 610   2              if (prio <= pip) {                            /*      PIP 'must' have a SMALLER prio ...       */
 611   3                  OS_EXIT_CRITICAL();                       /*      ... than current task!                   */
 612   3                  OS_Sched();                               /*      Find highest priority task ready to run  */
 613   3                  return (OS_ERR_PIP_LOWER);
 614   3              } else {
 615   3                  OS_EXIT_CRITICAL();
 616   3                  OS_Sched();                               /*      Find highest priority task ready to run  */
 617   3                  return (OS_ERR_NONE);
 618   3              }
 619   2          }
 620   1          pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
 621   1          pevent->OSEventPtr  = (void *)0;
 622   1          OS_EXIT_CRITICAL();
 623   1          return (OS_ERR_NONE);
 624   1      }
 625          /*$PAGE*/
 626          /*
 627          *********************************************************************************************************
 628          *                                     QUERY A MUTUAL EXCLUSION SEMAPHORE
 629          *
 630          * Description: This function obtains information about a mutex
 631          *
 632          * Arguments  : pevent          is a pointer to the event control block associated with the desired mutex
 633          *
 634          *              p_mutex_data    is a pointer to a structure that will contain information about the mutex
 635          *
 636          * Returns    : OS_ERR_NONE          The call was successful and the message was sent
 637          *              OS_ERR_QUERY_ISR     If you called this function from an ISR
 638          *              OS_ERR_PEVENT_NULL   If 'pevent'       is a NULL pointer
 639          *              OS_ERR_PDATA_NULL    If 'p_mutex_data' is a NULL pointer
 640          *              OS_ERR_EVENT_TYPE    If you are attempting to obtain data from a non mutex.
 641          *********************************************************************************************************
 642          */
 643          
 644          #if OS_MUTEX_QUERY_EN > 0u
 645          INT8U  OSMutexQuery (OS_EVENT       *pevent,
 646                               OS_MUTEX_DATA  *p_mutex_data)
 647          {
 648   1          INT8U       i;
 649   1          OS_PRIO    *psrc;
 650   1          OS_PRIO    *pdest;
 651   1      #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
*** WARNING C322 IN LINE 651 OF Source\os_mutex.c: unknown identifier
                  OS_CPU_SR   cpu_sr = 0u;
              #endif
 654   1      
 655   1      
 656   1      
 657   1          if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
 658   2              return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR        */
 659   2          }
 660   1      #if OS_ARG_CHK_EN > 0u
                  if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                      return (OS_ERR_PEVENT_NULL);
                  }
                  if (p_mutex_data == (OS_MUTEX_DATA *)0) {              /* Validate 'p_mutex_data'                  */
C51 COMPILER V9.51   OS_MUTEX                                                              02/25/2015 14:57:59 PAGE 12  

                      return (OS_ERR_PDATA_NULL);
                  }
              #endif
 668   1          if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
 669   2              return (OS_ERR_EVENT_TYPE);
 670   2          }
 671   1          OS_ENTER_CRITICAL();
 672   1          p_mutex_data->OSMutexPIP  = (INT8U)(pevent->OSEventCnt >> 8u);
 673   1          p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
 674   1          if (p_mutex_data->OSOwnerPrio == 0xFFu) {
 675   2              p_mutex_data->OSValue = OS_TRUE;
 676   2          } else {
 677   2              p_mutex_data->OSValue = OS_FALSE;
 678   2          }
 679   1          p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
 680   1          psrc                      = &pevent->OSEventTbl[0];
 681   1          pdest                     = &p_mutex_data->OSEventTbl[0];
 682   1          for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
 683   2              *pdest++ = *psrc++;
 684   2          }
 685   1          OS_EXIT_CRITICAL();
 686   1          return (OS_ERR_NONE);
 687   1      }
 688          #endif                                                     /* OS_MUTEX_QUERY_EN                        */
 689          
 690          /*$PAGE*/
 691          /*
 692          *********************************************************************************************************
 693          *                                RESTORE A TASK BACK TO ITS ORIGINAL PRIORITY
 694          *
 695          * Description: This function makes a task ready at the specified priority
 696          *
 697          * Arguments  : ptcb            is a pointer to OS_TCB of the task to make ready
 698          *
 699          *              prio            is the desired priority
 700          *
 701          * Returns    : none
 702          *********************************************************************************************************
 703          */
 704          
 705          static  void  OSMutex_RdyAtPrio (OS_TCB  *ptcb,
 706                                           INT8U    prio)
 707          {
 708   1          INT8U  y;
 709   1      
 710   1      
 711   1          y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
 712   1          OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;
 713   1          if (OSRdyTbl[y] == 0u) {
 714   2              OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
 715   2          }
 716   1          ptcb->OSTCBPrio         = prio;
 717   1          OSPrioCur               = prio;                        /* The current task is now at this priority */
 718   1      #if OS_LOWEST_PRIO <= 63u
 719   1          ptcb->OSTCBY            = (INT8U)((INT8U)(prio >> 3u) & 0x07u);
 720   1          ptcb->OSTCBX            = (INT8U)(prio & 0x07u);
 721   1      #else
                  ptcb->OSTCBY            = (INT8U)((INT8U)(prio >> 4u) & 0x0Fu);
                  ptcb->OSTCBX            = (INT8U) (prio & 0x0Fu);
              #endif
 725   1          ptcb->OSTCBBitY         = (OS_PRIO)(1uL << ptcb->OSTCBY);
 726   1          ptcb->OSTCBBitX         = (OS_PRIO)(1uL << ptcb->OSTCBX);
C51 COMPILER V9.51   OS_MUTEX                                                              02/25/2015 14:57:59 PAGE 13  

 727   1          OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
 728   1          OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 729   1          OSTCBPrioTbl[prio]      = ptcb;
 730   1      
 731   1      }
 732          
 733          
 734          #endif                                                     /* OS_MUTEX_EN                              */
 735                                                                                                                                                       
             -                                                                                


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2542    ----
   CONSTANT SIZE    =      2    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      64
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  7 WARNING(S),  0 ERROR(S)
