C51 COMPILER V9.51   OS_SEM                                                                02/25/2015 11:31:52 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE OS_SEM
OBJECT MODULE PLACED IN .\Output\os_sem.obj
COMPILER INVOKED BY: D:\Keil\C51\BIN\C51.EXE Source\os_sem.c BROWSE INCDIR(.\Source) DEBUG OBJECTEXTEND PRINT(.\List\os_
                    -sem.lst) TABS(2) OBJECT(.\Output\os_sem.obj)

line level    source

   1          /*
   2          *********************************************************************************************************
   3          *                                                uC/OS-II
   4          *                                          The Real-Time Kernel
   5          *                                          SEMAPHORE MANAGEMENT
   6          *
   7          *                              (c) Copyright 1992-2009, Micrium, Weston, FL
   8          *                                           All Rights Reserved
   9          *
  10          * File    : OS_SEM.C
  11          * By      : Jean J. Labrosse
  12          * Version : V2.91
  13          *
  14          * LICENSING TERMS:
  15          * ---------------
  16          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
  17          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license
  18          * its use in your product. We provide ALL the source code for your convenience and to help you experience
  19          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
  20          * licensing fee.
  21          *********************************************************************************************************
  22          */
  23          
  24          #ifndef  OS_MASTER_FILE
  25          #include <ucos_ii.h>
*** WARNING C318 IN LINE 44 OF .\Source\ucos_ii.h: can't open file 'app_cfg.h'
  26          #endif
  27          
  28          #if OS_SEM_EN > 0u
  29          /*$PAGE*/
  30          /*
  31          *********************************************************************************************************
  32          *                                           ACCEPT SEMAPHORE
  33          *
  34          * Description: This function checks the semaphore to see if a resource is available or, if an event
  35          *              occurred.  Unlike OSSemPend(), OSSemAccept() does not suspend the calling task if the
  36          *              resource is not available or the event did not occur.
  37          *
  38          * Arguments  : pevent     is a pointer to the event control block
  39          *
  40          * Returns    : >  0       if the resource is available or the event did not occur the semaphore is
  41          *                         decremented to obtain the resource.
  42          *              == 0       if the resource is not available or the event did not occur or,
  43          *                         if 'pevent' is a NULL pointer or,
  44          *                         if you didn't pass a pointer to a semaphore
  45          *********************************************************************************************************
  46          */
  47          
  48          #if OS_SEM_ACCEPT_EN > 0u
  49          INT16U  OSSemAccept (OS_EVENT *pevent)
  50          {
  51   1          INT16U     cnt;
  52   1      #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
*** WARNING C322 IN LINE 52 OF Source\os_sem.c: unknown identifier
C51 COMPILER V9.51   OS_SEM                                                                02/25/2015 11:31:52 PAGE 2   

                  OS_CPU_SR  cpu_sr = 0u;
              #endif
  55   1      
  56   1      
  57   1      
  58   1      #if OS_ARG_CHK_EN > 0u
                  if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                      return (0u);
                  }
              #endif
  63   1          if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
  64   2              return (0u);
  65   2          }
  66   1          OS_ENTER_CRITICAL();
  67   1          cnt = pevent->OSEventCnt;
  68   1          if (cnt > 0u) {                                   /* See if resource is available                  */
  69   2              pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
  70   2          }
  71   1          OS_EXIT_CRITICAL();
  72   1          return (cnt);                                     /* Return semaphore count                        */
  73   1      }
  74          #endif
  75          
  76          /*$PAGE*/
  77          /*
  78          *********************************************************************************************************
  79          *                                           CREATE A SEMAPHORE
  80          *
  81          * Description: This function creates a semaphore.
  82          *
  83          * Arguments  : cnt           is the initial value for the semaphore.  If the value is 0, no resource is
  84          *                            available (or no event has occurred).  You initialize the semaphore to a
  85          *                            non-zero value to specify how many resources are available (e.g. if you have
  86          *                            10 resources, you would initialize the semaphore to 10).
  87          *
  88          * Returns    : != (void *)0  is a pointer to the event control block (OS_EVENT) associated with the
  89          *                            created semaphore
  90          *              == (void *)0  if no event control blocks were available
  91          *********************************************************************************************************
  92          */
  93          
  94          OS_EVENT  *OSSemCreate (INT16U cnt)
  95          {
  96   1          OS_EVENT  *pevent;
  97   1      #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
*** WARNING C322 IN LINE 97 OF Source\os_sem.c: unknown identifier
                  OS_CPU_SR  cpu_sr = 0u;
              #endif
 100   1      
 101   1      
 102   1      
 103   1      #ifdef OS_SAFETY_CRITICAL_IEC61508
                  if (OSSafetyCriticalStartFlag == OS_TRUE) {
                      OS_SAFETY_CRITICAL_EXCEPTION();
                  }
              #endif
 108   1      
 109   1          if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
 110   2              return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
 111   2          }
 112   1          OS_ENTER_CRITICAL();
 113   1          pevent = OSEventFreeList;                              /* Get next free event control block        */
C51 COMPILER V9.51   OS_SEM                                                                02/25/2015 11:31:52 PAGE 3   

 114   1          if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
 115   2              OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
 116   2          }
 117   1          OS_EXIT_CRITICAL();
 118   1          if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
 119   2              pevent->OSEventType    = OS_EVENT_TYPE_SEM;
 120   2              pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
 121   2              pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
 122   2      #if OS_EVENT_NAME_EN > 0u
 123   2              pevent->OSEventName    = (INT8U *)(void *)"?";
 124   2      #endif
 125   2              OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
 126   2          }
 127   1          return (pevent);
 128   1      }
 129          
 130          /*$PAGE*/
 131          /*
 132          *********************************************************************************************************
 133          *                                         DELETE A SEMAPHORE
 134          *
 135          * Description: This function deletes a semaphore and readies all tasks pending on the semaphore.
 136          *
 137          * Arguments  : pevent        is a pointer to the event control block associated with the desired
 138          *                            semaphore.
 139          *
 140          *              opt           determines delete options as follows:
 141          *                            opt == OS_DEL_NO_PEND   Delete semaphore ONLY if no task pending
 142          *                            opt == OS_DEL_ALWAYS    Deletes the semaphore even if tasks are waiting.
 143          *                                                    In this case, all the tasks pending will be readied.
 144          *
 145          *              perr          is a pointer to an error code that can contain one of the following values:
 146          *                            OS_ERR_NONE             The call was successful and the semaphore was deleted
 147          *                            OS_ERR_DEL_ISR          If you attempted to delete the semaphore from an ISR
 148          *                            OS_ERR_INVALID_OPT      An invalid option was specified
 149          *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the semaphore
 150          *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a semaphore
 151          *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
 152          *
 153          * Returns    : pevent        upon error
 154          *              (OS_EVENT *)0 if the semaphore was successfully deleted.
 155          *
 156          * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
 157          *                 the semaphore MUST check the return code of OSSemPend().
 158          *              2) OSSemAccept() callers will not know that the intended semaphore has been deleted unless
 159          *                 they check 'pevent' to see that it's a NULL pointer.
 160          *              3) This call can potentially disable interrupts for a long time.  The interrupt disable
 161          *                 time is directly proportional to the number of tasks waiting on the semaphore.
 162          *              4) Because ALL tasks pending on the semaphore will be readied, you MUST be careful in
 163          *                 applications where the semaphore is used for mutual exclusion because the resource(s)
 164          *                 will no longer be guarded by the semaphore.
 165          *********************************************************************************************************
 166          */
 167          
 168          #if OS_SEM_DEL_EN > 0u
 169          OS_EVENT  *OSSemDel (OS_EVENT  *pevent,
 170                               INT8U      opt,
 171                               INT8U     *perr)
 172          {
 173   1          BOOLEAN    tasks_waiting;
 174   1          OS_EVENT  *pevent_return;
 175   1      #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
C51 COMPILER V9.51   OS_SEM                                                                02/25/2015 11:31:52 PAGE 4   

*** WARNING C322 IN LINE 175 OF Source\os_sem.c: unknown identifier
                  OS_CPU_SR  cpu_sr = 0u;
              #endif
 178   1      
 179   1      
 180   1      
 181   1      #ifdef OS_SAFETY_CRITICAL
                  if (perr == (INT8U *)0) {
                      OS_SAFETY_CRITICAL_EXCEPTION();
                  }
              #endif
 186   1      
 187   1      #if OS_ARG_CHK_EN > 0u
                  if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                      *perr = OS_ERR_PEVENT_NULL;
                      return (pevent);
                  }
              #endif
 193   1          if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
 194   2              *perr = OS_ERR_EVENT_TYPE;
 195   2              return (pevent);
 196   2          }
 197   1          if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
 198   2              *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
 199   2              return (pevent);
 200   2          }
 201   1          OS_ENTER_CRITICAL();
 202   1          if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on semaphore    */
 203   2              tasks_waiting = OS_TRUE;                           /* Yes                                      */
 204   2          } else {
 205   2              tasks_waiting = OS_FALSE;                          /* No                                       */
 206   2          }
 207   1          switch (opt) {
 208   2              case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
 209   2                   if (tasks_waiting == OS_FALSE) {
 210   3      #if OS_EVENT_NAME_EN > 0u
 211   3                       pevent->OSEventName    = (INT8U *)(void *)"?";
 212   3      #endif
 213   3                       pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 214   3                       pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
 215   3                       pevent->OSEventCnt     = 0u;
 216   3                       OSEventFreeList        = pevent;          /* Get next free event control block        */
 217   3                       OS_EXIT_CRITICAL();
 218   3                       *perr                  = OS_ERR_NONE;
 219   3                       pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
 220   3                   } else {
 221   3                       OS_EXIT_CRITICAL();
 222   3                       *perr                  = OS_ERR_TASK_WAITING;
 223   3                       pevent_return          = pevent;
 224   3                   }
 225   2                   break;
 226   2      
 227   2              case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
 228   2                   while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for semaphore    */
 229   3                       (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
 230   3                   }
 231   2      #if OS_EVENT_NAME_EN > 0u
 232   2                   pevent->OSEventName    = (INT8U *)(void *)"?";
 233   2      #endif
 234   2                   pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 235   2                   pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
 236   2                   pevent->OSEventCnt     = 0u;
C51 COMPILER V9.51   OS_SEM                                                                02/25/2015 11:31:52 PAGE 5   

 237   2                   OSEventFreeList        = pevent;              /* Get next free event control block        */
 238   2                   OS_EXIT_CRITICAL();
 239   2                   if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 240   3                       OS_Sched();                               /* Find highest priority task ready to run  */
 241   3                   }
 242   2                   *perr                  = OS_ERR_NONE;
 243   2                   pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
 244   2                   break;
 245   2      
 246   2              default:
 247   2                   OS_EXIT_CRITICAL();
 248   2                   *perr                  = OS_ERR_INVALID_OPT;
 249   2                   pevent_return          = pevent;
 250   2                   break;
 251   2          }
 252   1          return (pevent_return);
 253   1      }
 254          #endif
 255          
 256          /*$PAGE*/
 257          /*
 258          *********************************************************************************************************
 259          *                                           PEND ON SEMAPHORE
 260          *
 261          * Description: This function waits for a semaphore.
 262          *
 263          * Arguments  : pevent        is a pointer to the event control block associated with the desired
 264          *                            semaphore.
 265          *
 266          *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
 267          *                            wait for the resource up to the amount of time specified by this argument.
 268          *                            If you specify 0, however, your task will wait forever at the specified
 269          *                            semaphore or, until the resource becomes available (or the event occurs).
 270          *
 271          *              perr          is a pointer to where an error message will be deposited.  Possible error
 272          *                            messages are:
 273          *
 274          *                            OS_ERR_NONE         The call was successful and your task owns the resource
 275          *                                                or, the event you are waiting for occurred.
 276          *                            OS_ERR_TIMEOUT      The semaphore was not received within the specified
 277          *                                                'timeout'.
 278          *                            OS_ERR_PEND_ABORT   The wait on the semaphore was aborted.
 279          *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore.
 280          *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
 281          *                                                would lead to a suspension.
 282          *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
 283          *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked
 284          *
 285          * Returns    : none
 286          *********************************************************************************************************
 287          */
 288          /*$PAGE*/
 289          void  OSSemPend (OS_EVENT  *pevent,
 290                           INT32U     timeout,
 291                           INT8U     *perr)
 292          {
 293   1      #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
*** WARNING C322 IN LINE 293 OF Source\os_sem.c: unknown identifier
                  OS_CPU_SR  cpu_sr = 0u;
              #endif
 296   1      
 297   1      
C51 COMPILER V9.51   OS_SEM                                                                02/25/2015 11:31:52 PAGE 6   

 298   1      
 299   1      #ifdef OS_SAFETY_CRITICAL
                  if (perr == (INT8U *)0) {
                      OS_SAFETY_CRITICAL_EXCEPTION();
                  }
              #endif
 304   1      
 305   1      #if OS_ARG_CHK_EN > 0u
                  if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                      *perr = OS_ERR_PEVENT_NULL;
                      return;
                  }
              #endif
 311   1          if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 312   2              *perr = OS_ERR_EVENT_TYPE;
 313   2              return;
 314   2          }
 315   1          if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
 316   2              *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
 317   2              return;
 318   2          }
 319   1          if (OSLockNesting > 0u) {                         /* See if called with scheduler locked ...       */
 320   2              *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
 321   2              return;
 322   2          }
 323   1          OS_ENTER_CRITICAL();
 324   1          if (pevent->OSEventCnt > 0u) {                    /* If sem. is positive, resource available ...   */
 325   2              pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
 326   2              OS_EXIT_CRITICAL();
 327   2              *perr = OS_ERR_NONE;
 328   2              return;
 329   2          }
 330   1                                                            /* Otherwise, must wait until event occurs       */
 331   1          OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
 332   1          OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 333   1          OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
 334   1          OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
 335   1          OS_EXIT_CRITICAL();
 336   1          OS_Sched();                                       /* Find next highest priority task ready         */
 337   1          OS_ENTER_CRITICAL();
 338   1          switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
 339   2              case OS_STAT_PEND_OK:
 340   2                   *perr = OS_ERR_NONE;
 341   2                   break;
 342   2      
 343   2              case OS_STAT_PEND_ABORT:
 344   2                   *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
 345   2                   break;
 346   2      
 347   2              case OS_STAT_PEND_TO:
 348   2              default:
 349   2                   OS_EventTaskRemove(OSTCBCur, pevent);
 350   2                   *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
 351   2                   break;
 352   2          }
 353   1          OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
 354   1          OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
 355   1          OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
 356   1      #if (OS_EVENT_MULTI_EN > 0u)
 357   1          OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 358   1      #endif
 359   1          OS_EXIT_CRITICAL();
C51 COMPILER V9.51   OS_SEM                                                                02/25/2015 11:31:52 PAGE 7   

 360   1      }
 361          
 362          /*$PAGE*/
 363          /*
 364          *********************************************************************************************************
 365          *                                      ABORT WAITING ON A SEMAPHORE
 366          *
 367          * Description: This function aborts & readies any tasks currently waiting on a semaphore.  This function
 368          *              should be used to fault-abort the wait on the semaphore, rather than to normally signal
 369          *              the semaphore via OSSemPost().
 370          *
 371          * Arguments  : pevent        is a pointer to the event control block associated with the desired
 372          *                            semaphore.
 373          *
 374          *              opt           determines the type of ABORT performed:
 375          *                            OS_PEND_OPT_NONE         ABORT wait for a single task (HPT) waiting on the
 376          *                                                     semaphore
 377          *                            OS_PEND_OPT_BROADCAST    ABORT wait for ALL tasks that are  waiting on the
 378          *                                                     semaphore
 379          *
 380          *              perr          is a pointer to where an error message will be deposited.  Possible error
 381          *                            messages are:
 382          *
 383          *                            OS_ERR_NONE         No tasks were     waiting on the semaphore.
 384          *                            OS_ERR_PEND_ABORT   At least one task waiting on the semaphore was readied
 385          *                                                and informed of the aborted wait; check return value
 386          *                                                for the number of tasks whose wait on the semaphore
 387          *                                                was aborted.
 388          *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore.
 389          *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
 390          *
 391          * Returns    : == 0          if no tasks were waiting on the semaphore, or upon error.
 392          *              >  0          if one or more tasks waiting on the semaphore are now readied and informed.
 393          *********************************************************************************************************
 394          */
 395          
 396          #if OS_SEM_PEND_ABORT_EN > 0u
 397          INT8U  OSSemPendAbort (OS_EVENT  *pevent,
 398                                 INT8U      opt,
 399                                 INT8U     *perr)
 400          {
 401   1          INT8U      nbr_tasks;
 402   1      #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
*** WARNING C322 IN LINE 402 OF Source\os_sem.c: unknown identifier
                  OS_CPU_SR  cpu_sr = 0u;
              #endif
 405   1      
 406   1      
 407   1      
 408   1      #ifdef OS_SAFETY_CRITICAL
                  if (perr == (INT8U *)0) {
                      OS_SAFETY_CRITICAL_EXCEPTION();
                  }
              #endif
 413   1      
 414   1      #if OS_ARG_CHK_EN > 0u
                  if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                      *perr = OS_ERR_PEVENT_NULL;
                      return (0u);
                  }
              #endif
 420   1          if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
C51 COMPILER V9.51   OS_SEM                                                                02/25/2015 11:31:52 PAGE 8   

 421   2              *perr = OS_ERR_EVENT_TYPE;
 422   2              return (0u);
 423   2          }
 424   1          OS_ENTER_CRITICAL();
 425   1          if (pevent->OSEventGrp != 0u) {                   /* See if any task waiting on semaphore?         */
 426   2              nbr_tasks = 0u;
 427   2              switch (opt) {
 428   3                  case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
 429   3                       while (pevent->OSEventGrp != 0u) {   /* Yes, ready ALL tasks waiting on semaphore     */
 430   4                           (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
 431   4                           nbr_tasks++;
 432   4                       }
 433   3                       break;
 434   3      
 435   3                  case OS_PEND_OPT_NONE:
 436   3                  default:                                  /* No,  ready HPT       waiting on semaphore     */
 437   3                       (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
 438   3                       nbr_tasks++;
 439   3                       break;
 440   3              }
 441   2              OS_EXIT_CRITICAL();
 442   2              OS_Sched();                                   /* Find HPT ready to run                         */
 443   2              *perr = OS_ERR_PEND_ABORT;
 444   2              return (nbr_tasks);
 445   2          }
 446   1          OS_EXIT_CRITICAL();
 447   1          *perr = OS_ERR_NONE;
 448   1          return (0u);                                      /* No tasks waiting on semaphore                 */
 449   1      }
 450          #endif
 451          
 452          /*$PAGE*/
 453          /*
 454          *********************************************************************************************************
 455          *                                         POST TO A SEMAPHORE
 456          *
 457          * Description: This function signals a semaphore
 458          *
 459          * Arguments  : pevent        is a pointer to the event control block associated with the desired
 460          *                            semaphore.
 461          *
 462          * Returns    : OS_ERR_NONE         The call was successful and the semaphore was signaled.
 463          *              OS_ERR_SEM_OVF      If the semaphore count exceeded its limit.  In other words, you have
 464          *                                  signalled the semaphore more often than you waited on it with either
 465          *                                  OSSemAccept() or OSSemPend().
 466          *              OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore
 467          *              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
 468          *********************************************************************************************************
 469          */
 470          
 471          INT8U  OSSemPost (OS_EVENT *pevent)
 472          {
 473   1      #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
*** WARNING C322 IN LINE 473 OF Source\os_sem.c: unknown identifier
                  OS_CPU_SR  cpu_sr = 0u;
              #endif
 476   1      
 477   1      
 478   1      
 479   1      #if OS_ARG_CHK_EN > 0u
                  if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                      return (OS_ERR_PEVENT_NULL);
C51 COMPILER V9.51   OS_SEM                                                                02/25/2015 11:31:52 PAGE 9   

                  }
              #endif
 484   1          if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 485   2              return (OS_ERR_EVENT_TYPE);
 486   2          }
 487   1          OS_ENTER_CRITICAL();
 488   1          if (pevent->OSEventGrp != 0u) {                   /* See if any task waiting for semaphore         */
 489   2                                                            /* Ready HPT waiting on event                    */
 490   2              (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
 491   2              OS_EXIT_CRITICAL();
 492   2              OS_Sched();                                   /* Find HPT ready to run                         */
 493   2              return (OS_ERR_NONE);
 494   2          }
 495   1          if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
 496   2              pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
 497   2              OS_EXIT_CRITICAL();
 498   2              return (OS_ERR_NONE);
 499   2          }
 500   1          OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
 501   1          return (OS_ERR_SEM_OVF);
 502   1      }
 503          
 504          /*$PAGE*/
 505          /*
 506          *********************************************************************************************************
 507          *                                          QUERY A SEMAPHORE
 508          *
 509          * Description: This function obtains information about a semaphore
 510          *
 511          * Arguments  : pevent        is a pointer to the event control block associated with the desired
 512          *                            semaphore
 513          *
 514          *              p_sem_data    is a pointer to a structure that will contain information about the
 515          *                            semaphore.
 516          *
 517          * Returns    : OS_ERR_NONE         The call was successful and the message was sent
 518          *              OS_ERR_EVENT_TYPE   If you are attempting to obtain data from a non semaphore.
 519          *              OS_ERR_PEVENT_NULL  If 'pevent'     is a NULL pointer.
 520          *              OS_ERR_PDATA_NULL   If 'p_sem_data' is a NULL pointer
 521          *********************************************************************************************************
 522          */
 523          
 524          #if OS_SEM_QUERY_EN > 0u
 525          INT8U  OSSemQuery (OS_EVENT     *pevent,
 526                             OS_SEM_DATA  *p_sem_data)
 527          {
 528   1          INT8U       i;
 529   1          OS_PRIO    *psrc;
 530   1          OS_PRIO    *pdest;
 531   1      #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
*** WARNING C322 IN LINE 531 OF Source\os_sem.c: unknown identifier
                  OS_CPU_SR   cpu_sr = 0u;
              #endif
 534   1      
 535   1      
 536   1      
 537   1      #if OS_ARG_CHK_EN > 0u
                  if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
                      return (OS_ERR_PEVENT_NULL);
                  }
                  if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
                      return (OS_ERR_PDATA_NULL);
C51 COMPILER V9.51   OS_SEM                                                                02/25/2015 11:31:52 PAGE 10  

                  }
              #endif
 545   1          if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
 546   2              return (OS_ERR_EVENT_TYPE);
 547   2          }
 548   1          OS_ENTER_CRITICAL();
 549   1          p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
 550   1          psrc                   = &pevent->OSEventTbl[0];
 551   1          pdest                  = &p_sem_data->OSEventTbl[0];
 552   1          for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
 553   2              *pdest++ = *psrc++;
 554   2          }
 555   1          p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
 556   1          OS_EXIT_CRITICAL();
 557   1          return (OS_ERR_NONE);
 558   1      }
 559          #endif                                                     /* OS_SEM_QUERY_EN                          */
 560          
 561          /*$PAGE*/
 562          /*
 563          *********************************************************************************************************
 564          *                                              SET SEMAPHORE
 565          *
 566          * Description: This function sets the semaphore count to the value specified as an argument.  Typically,
 567          *              this value would be 0.
 568          *
 569          *              You would typically use this function when a semaphore is used as a signaling mechanism
 570          *              and, you want to reset the count value.
 571          *
 572          * Arguments  : pevent     is a pointer to the event control block
 573          *
 574          *              cnt        is the new value for the semaphore count.  You would pass 0 to reset the
 575          *                         semaphore count.
 576          *
 577          *              perr       is a pointer to an error code returned by the function as follows:
 578          *
 579          *                            OS_ERR_NONE          The call was successful and the semaphore value was set.
 580          *                            OS_ERR_EVENT_TYPE    If you didn't pass a pointer to a semaphore.
 581          *                            OS_ERR_PEVENT_NULL   If 'pevent' is a NULL pointer.
 582          *                            OS_ERR_TASK_WAITING  If tasks are waiting on the semaphore.
 583          *********************************************************************************************************
 584          */
 585          
 586          #if OS_SEM_SET_EN > 0u
 587          void  OSSemSet (OS_EVENT  *pevent,
 588                          INT16U     cnt,
 589                          INT8U     *perr)
 590          {
 591   1      #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
*** WARNING C322 IN LINE 591 OF Source\os_sem.c: unknown identifier
                  OS_CPU_SR  cpu_sr = 0u;
              #endif
 594   1      
 595   1      
 596   1      
 597   1      #ifdef OS_SAFETY_CRITICAL
                  if (perr == (INT8U *)0) {
                      OS_SAFETY_CRITICAL_EXCEPTION();
                  }
              #endif
 602   1      
 603   1      #if OS_ARG_CHK_EN > 0u
C51 COMPILER V9.51   OS_SEM                                                                02/25/2015 11:31:52 PAGE 11  

                  if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
                      *perr = OS_ERR_PEVENT_NULL;
                      return;
                  }
              #endif
 609   1          if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 610   2              *perr = OS_ERR_EVENT_TYPE;
 611   2              return;
 612   2          }
 613   1          OS_ENTER_CRITICAL();
 614   1          *perr = OS_ERR_NONE;
 615   1          if (pevent->OSEventCnt > 0u) {                    /* See if semaphore already has a count          */
 616   2              pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
 617   2          } else {                                          /* No                                            */
 618   2              if (pevent->OSEventGrp == 0u) {               /*      See if task(s) waiting?                  */
 619   3                  pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
 620   3              } else {
 621   3                  *perr              = OS_ERR_TASK_WAITING;
 622   3              }
 623   2          }
 624   1          OS_EXIT_CRITICAL();
 625   1      }
 626          #endif
 627          
 628          #endif                                                /* OS_SEM_EN                                     */
 629                                                                                                                                                       
             -                                                                                


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1305    ----
   CONSTANT SIZE    =      2    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      54
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  9 WARNING(S),  0 ERROR(S)
